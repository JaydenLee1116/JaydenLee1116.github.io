{"componentChunkName":"component---src-templates-blog-template-js","path":"/from-time-to-time/study/cs-network/cookie-session/","result":{"data":{"cur":{"id":"649ca040-f344-5ca0-ba5e-677cda03fa97","html":"<h2 id=\"-cs-network-스터디\" style=\"position:relative;\"><a href=\"#-cs-network-%EC%8A%A4%ED%84%B0%EB%94%94\" aria-label=\" cs network 스터디 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧷 CS-Network 스터디</h2>\n<p>코드스쿼드 과정을 마치고 프론트엔드 개발자로서 알아야될 네트워크 지식을 채우기 위해 시작한 CS 스터디!<br/>\n<a href=\"https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md\">Tech-Interview-Network</a>를 참고하여 스터디를 진행하기로 했다.</p>\n<h1 id=\"1-쿠키와-세션의-차이에-대해-설명해주세요\" style=\"position:relative;\"><a href=\"#1-%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"1 쿠키와 세션의 차이에 대해 설명해주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 쿠키와 세션의 차이에 대해 설명해주세요.</h1>\n<p>먼저 쿠키와 세션은 모두 HTTP의 connectionless, stateless를 보완하기 위해 등장한 기술입니다.</p>\n<p>단순하게 생각하면 쿠키는 클라이언트 측에 사용자 정보 등의 데이터를 저장하는 기술이고 세션은 서버 측에 데이터를 저장하는 기술입니다. 그렇기 때문에 서버의 과부하 면에서는 세션보단 쿠키가 유리하고 보안 면에서는 쿠키보단 세션이 유리합니다. 이 둘의 가장 큰 차이는 데이터가 유지되는 유효 시간 관리에 있습니다. 쿠키는 서버에서 쿠키를\u001d 만들 때 정한 유효시간 동안 계속 유지되지만 언제든지 클라이언트가 수정 및 삭제가 가능하다는 특징이 있습니다. 반면 세션은 클라이언트가 직접 데이터의 라이프사이클에 개입할 수 없으며 서버에서 정한 규칙에 따라서 세션이 만료된다는 특징이 있습니다.</p>\n<blockquote>\n<p>용량, 서버 부하, 보안 등의 차이가 있지만 라이프 사이클에 대한 대답을 하는 게 가장 좋다고 한다!<br/>\n세션 쿠키: 서버에서 쿠키를 만들 때, 유효시간을 지정하지 않은 경우로 브라우저를 닫으면 삭제된다.</p>\n</blockquote>\n<h2 id=\"1-세션-방식의-로그인-과정에-대해-설명해주세요\" style=\"position:relative;\"><a href=\"#1-%EC%84%B8%EC%85%98-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"1 세션 방식의 로그인 과정에 대해 설명해주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 세션 방식의 로그인 과정에 대해 설명해주세요.</h2>\n<p>먼저 세션은 유저가 웹서버에 접속해 있는 상태를 하나의 단위로 한 개념입니다. 이 때, 각 단위인 세션에 대해 id를 부여한 것이 세션 id가 됩니다.</p>\n<ul>\n<li>클라이언트가 로그인 정보(유저id, 암호 등)와 함께 서버에 로그인 요청을 보냅니다.</li>\n<li>서버는 로그인 인증을 하고 해당 정보가 유효하면 세션 객체를 생성하여 해당 세션에 대한 id를 응답 헤더의 Set-cookie를 통해 전달합니다.</li>\n<li>클라이언트는 응답 헤더의 Set-cookie에 따라 쿠키 저장소에 세션 id를 저장하게 되고 이후 요청 시, 세션 id를 헤더에 담아 전달합니다.</li>\n<li>서버는 클라이언트가 요청과 함께 보낸 세션 id를 통해 관리 중인 세션에서 정보를 찾아 응답합니다.</li>\n</ul>\n<blockquote>\n<p>세션 방식은 서버에 유저 정보를 세션으로 관리하기에 부하가 온다는 단점이 있다.<br/>\n또한 서버를 확장할 때, 모든 서버가 세션을 공유 혹은 갖고 있어야하므로 비효율적일 수 있다.<br/>\n유저의 정보를 서버에서 갖고 있다는 점은 일반적으로 보안이 좋다는 의미긴 하지만, 이건 어디까지나 서버가 보안이 잘 되어있을 때이다.<br/>\nJWT 로그인 방식과 자주 비교된다.</p>\n</blockquote>\n<h2 id=\"2-http의-특성인-stateless에-대해-설명해주세요\" style=\"position:relative;\"><a href=\"#2-http%EC%9D%98-%ED%8A%B9%EC%84%B1%EC%9D%B8-stateless%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"2 http의 특성인 stateless에 대해 설명해주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. HTTP의 특성인 Stateless에 대해 설명해주세요.</h2>\n<p>상태를 갖고 있지 않다는 의미로 주로 <code class=\"language-text\">서버에서 기억되어지는 데이터가 없음</code>을 의미합니다. 즉, 클라이언트가 요청을 할 때마다 응답에 필요한 데이터를 매번 보내야합니다. 만약 이전 요청에서 전달받은 데이터를 기반으로 그 다음 요청에 응답을 한다면 이는 서버에서 상태를 유지하고 있는 게 됩니다. 이렇게 stateless하게 유지하면 언제든 서버를 대체할 수 있고 쉽게 확장할 수 있다는 장점이 있습니다.</p>\n<h2 id=\"3-stateless의-의미를-살펴보면-세션은-적절하지-않은-인증-방법-아닌가요\" style=\"position:relative;\"><a href=\"#3-stateless%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%A9%B4-%EC%84%B8%EC%85%98%EC%9D%80-%EC%A0%81%EC%A0%88%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EB%B2%95-%EC%95%84%EB%8B%8C%EA%B0%80%EC%9A%94\" aria-label=\"3 stateless의 의미를 살펴보면 세션은 적절하지 않은 인증 방법 아닌가요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</h2>\n<p>stateless의 의미만을 살펴보면 세션은 stateless하지 않기에 적절하지 않다고 할 수 있습니다. 하지만 예를 들어 로그인 후 회원의 로그인 유무를 유지하는 기능을 구현할 때, HTTP의 stateless한 성질을 유지하면서 매 요청마다 회원의 로그인 정보를 전달하는 것은 효율적이지 않습니다. 이를 극복하기 위해 세션과 같은 state를 부여한 것이므로 기능의 효율면에서는 적절하다고 생각합니다.</p>\n<h2 id=\"4-규모가-커져-서버가-여러-개가-된다면-세션을-어떻게-관리할-수-있을까요\" style=\"position:relative;\"><a href=\"#4-%EA%B7%9C%EB%AA%A8%EA%B0%80-%EC%BB%A4%EC%A0%B8-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%97%AC%EB%9F%AC-%EA%B0%9C%EA%B0%80-%EB%90%9C%EB%8B%A4%EB%A9%B4-%EC%84%B8%EC%85%98%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94\" aria-label=\"4 규모가 커져 서버가 여러 개가 된다면 세션을 어떻게 관리할 수 있을까요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</h2>\n<p>특정 유저에 대해서는 고정된 서버를 사용하게끔하는 Sticky Session 방법이 있습니다. 로드 밸런서는 요청 헤더의 쿠키를 확인하고 쿠키가 존재하지 않으면 로드 밸런싱 알고리즘으로 해당 요청에 대한 서버를 부여하고 쿠키가 존재하면 이전에 통신했던 서버로 요청을 전달합니다. 하지만 이 방법 또한 서버 하나가 죽으면 유저가 재요청해야하고 우연히 특정 서버로 트래픽이 몰리는 경우가 생길 수 있는 단점이 있습니다.<br/>\n가장 이상적으로 생각해보면 모든 서버를 하나의 서버처럼 다룰 수 있다면 위와 같은 문제들을 해결할 수 있게 됩니다. 이렇게 여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 하는 것을 클러스터링이라고 합니다.\n첫번째 클러스터링 방식으로 All-to-All 방식이 있습니다. 요청에 대한 세션을 특정 서버에 저장하고 저장된 세션 객체를 복제하여 모든 서버에 전달하여 보관합니다. 요청에 대해서 모든 서버가 동일한 응답을 할 수 있지만, 동일한 세션 객체를 모든 서버가 저장하고 있어야 하므로 메모리에 과하게 필요하다는 단점이 있습니다.<br/>\n다음으로는 Primary-secondary 방식이 있습니다. 이는 세션 객체를 저장한 서버를 Primary로 두고 그 객체를 복제하여 전달받은 서버를 Secondary로 두는 방식입니다. 즉, 백업용 서버라고 볼 수 있습니다. 그리고 나서 나머지 서버들은 Key에 해당하는 Session ID만을 저장함으로써 이전 방법보단 메모리를 아낄 수 있습니다. 다만, 이 방식도 Session ID만을 갖고 있는 서버는 세션 객체를 갖고 있는 Primary 서버에게 요청을 해야한다는 단점이 있습니다.</p>\n<h2 id=\"참고-자료\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\" aria-label=\"참고 자료 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고 자료</h2>\n<ul>\n<li><a href=\"https://interconnection.tistory.com/74\">쿠키와 세션 개념</a></li>\n<li><a href=\"https://80000coding.oopy.io/1f213f10-185c-4b4e-8372-119402fecdd0\">로그인 인증 방식 어떤 게 좋을까? Session VS JWT</a></li>\n<li><a href=\"https://velog.io/@gwontaeyong/Session-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Stateless\">Session 그리고 Stateless</a></li>\n<li><a href=\"https://hyuntaeknote.tistory.com/6\">다중 서버 환경에서 Session은 어떻게 공유하고 관리할까?</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-cs-network-%EC%8A%A4%ED%84%B0%EB%94%94\">🧷 CS-Network 스터디</a></li>\n<li><a href=\"#1-%EC%84%B8%EC%85%98-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94\">1. 세션 방식의 로그인 과정에 대해 설명해주세요.</a></li>\n<li><a href=\"#2-http%EC%9D%98-%ED%8A%B9%EC%84%B1%EC%9D%B8-stateless%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94\">2. HTTP의 특성인 Stateless에 대해 설명해주세요.</a></li>\n<li><a href=\"#3-stateless%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EC%82%B4%ED%8E%B4%EB%B3%B4%EB%A9%B4-%EC%84%B8%EC%85%98%EC%9D%80-%EC%A0%81%EC%A0%88%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EB%B2%95-%EC%95%84%EB%8B%8C%EA%B0%80%EC%9A%94\">3. Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?</a></li>\n<li><a href=\"#4-%EA%B7%9C%EB%AA%A8%EA%B0%80-%EC%BB%A4%EC%A0%B8-%EC%84%9C%EB%B2%84%EA%B0%80-%EC%97%AC%EB%9F%AC-%EA%B0%9C%EA%B0%80-%EB%90%9C%EB%8B%A4%EB%A9%B4-%EC%84%B8%EC%85%98%EC%9D%84-%EC%96%B4%EB%96%BB%EA%B2%8C-%EA%B4%80%EB%A6%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94\">4. 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C\">참고 자료</a></li>\n</ul>\n</div>","excerpt":"🧷 CS-Network 스터디 코드스쿼드 과정을 마치고 프론트엔드 개발자로서 알아야될 네트워크 지식을 채우기 위해 시작한 CS 스터디!\nTech-Interview-Network를 참고하여 스터디를 진행하기로 했다. 1. 쿠키와 세션의 차이에 대해 설명해주세요. 먼저 쿠키와 세션은 모두 HTTP의 connectionless, stateless를 보완하기 위해 등장한 기술입니다. 단순하게 생각하면 쿠키는 클라이언트 측에 사용자 정보 등의 데이터를 저장하는 기술이고 세션은 서버 측에 데이터를 저장하는 기술입니다. 그렇기 때문에 서버의 과부하 면에서는 세션보단 쿠키가 유리하고 보안 면에서는 쿠키보단 세션이 유리합니다. 이 둘의 가장 큰 차이는 데이터가 유지되는 유효 시간 관리에 있습니다. 쿠키는 서버에서 쿠키를\u001d 만들 때 정한 유효시간 동안 계속 유지되지만 언제든지 클라이언트가 수정 및 삭제가 가능하다는 특징이 있습니다. 반면 세션은 클라이언트가 직접 데이터의 라이프사이클에 개입할 수 없…","frontmatter":{"date":"July 16, 2023","title":"CS-Network. 쿠키와 세션에 대해","categories":"스터디","author":"제이든","emoji":"🧷"},"fields":{"slug":"/from-time-to-time/study/cs-network/cookie-session/"}},"next":{"id":"3208abad-644c-5c79-87df-99880e734e5e","html":"<h2 id=\"-성장일지-60\" style=\"position:relative;\"><a href=\"#-%EC%84%B1%EC%9E%A5%EC%9D%BC%EC%A7%80-60\" aria-label=\" 성장일지 60 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚤 성장일지 6.0</h2>\n<p>책 <code class=\"language-text\">행복한 이기주의자(웨인 다이어)</code>의 내용에 자극받아 시작하는 소박한 <code class=\"language-text\">성장기록</code></p>\n<blockquote>\n<p>살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>\n성장하고 있는 것이 살아 있는 것이다.<br/>\n생명의 유일한 증거는 성장이다!</p>\n</blockquote>\n<blockquote>\n<p>🌾 (4.0)학습 키워드에서 최대한 간단한 정보 제공, 고민에서 내 경험을 자세히 적자!<br/>\n🥊 (5.0)학습 키워드는 한줄의 핵심으로만 정리, 성공/실패 일지 작성하기! 이 때, 실패의 경험은 자세히 적기!<br/>\n🍉 (6.0)&#x3C;완전 개편!!!> 매일 습관적으로 핵심만 적을 수 있게 프레임 변경. 성공보단 실패에 초점을 맞추기.<br/></p>\n<ul>\n<li>🍉 (6.1)&#x3C;수정> 매번 성공, 실패를 따로 적는 것보단 경험으로 표현하자</li>\n</ul>\n</blockquote>\n<h2 id=\"-오늘의-감정\" style=\"position:relative;\"><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B0%90%EC%A0%95\" aria-label=\" 오늘의 감정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🌈 오늘의 감정</h2>\n<p>진짜 열심히 살고 있다. 뿌듯하고 보람차다. 더 계속 나아가고 싶고 더 많이 배우고 싶다. 이런 감정을 느끼고 적을 수 있음에 감사한 하루다.</p>\n<h2 id=\"-오늘의-고민\" style=\"position:relative;\"><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B3%A0%EB%AF%BC\" aria-label=\" 오늘의 고민 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🫧 오늘의 고민</h2>\n<h3 id=\"각각의-reducer에서-초기-상태값을-전달하지-않고-combinereducers-후에-createstore할-때-초기-상태를-전달할-수-없을까\" style=\"position:relative;\"><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%98-reducer%EC%97%90%EC%84%9C-%EC%B4%88%EA%B8%B0-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-combinereducers-%ED%9B%84%EC%97%90-createstore%ED%95%A0-%EB%95%8C-%EC%B4%88%EA%B8%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%A0-%EC%88%98-%EC%97%86%EC%9D%84%EA%B9%8C\" aria-label=\"각각의 reducer에서 초기 상태값을 전달하지 않고 combinereducers 후에 createstore할 때 초기 상태를 전달할 수 없을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>각각의 reducer에서 초기 상태값을 전달하지 않고, combineReducers 후에 createStore할 때 초기 상태를 전달할 수 없을까?</h3>\n<p>결론만 말하면 안되는 걸로! rootReducer를 생성할 때, combineReducers에 각 reducer들을 담아 호출하게 되는데 이 때, 리덕스가 내부적으로 각 reducer를 호출하여 값을 받는다.\n즉, 초기값이 없으면 에러가 발생한다는 이야기다. 그러므로 각각의 reducer에 초기 상태값을 전달해줘야 한다.</p>\n<h3 id=\"http의-stateless-면에서-봤을-때-session-기반의-방식은-적절하지-못한-거-아닌가\" style=\"position:relative;\"><a href=\"#http%EC%9D%98-stateless-%EB%A9%B4%EC%97%90%EC%84%9C-%EB%B4%A4%EC%9D%84-%EB%95%8C-session-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B0%A9%EC%8B%9D%EC%9D%80-%EC%A0%81%EC%A0%88%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EA%B1%B0-%EC%95%84%EB%8B%8C%EA%B0%80\" aria-label=\"http의 stateless 면에서 봤을 때 session 기반의 방식은 적절하지 못한 거 아닌가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HTTP의 stateless 면에서 봤을 때, session 기반의 방식은 적절하지 못한 거 아닌가?</h3>\n<p>stateless의 의미만을 살펴보면 세션은 stateless하지 않기에 적절하지 않다고 할 수 있다.\n하지만 예를 들어 로그인 후 회원의 로그인 유무를 유지하는 기능을 구현할 때, HTTP의 stateless한 성질을 유지하면서 매 요청마다 회원의 로그인 정보를 전달하는 것은 효율적이지 않다.\n이를 극복하기 위해 세션과 같은 state를 부여한 것이므로 기능의 효율면에서는 적절하다고 생각한다.</p>\n<h2 id=\"️-오늘의-경험\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B2%BD%ED%97%98\" aria-label=\"️ 오늘의 경험 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☀️ 오늘의 경험</h2>\n<h3 id=\"redux의-action-action-creator-reducer-그리고-combinereducers\" style=\"position:relative;\"><a href=\"#redux%EC%9D%98-action-action-creator-reducer-%EA%B7%B8%EB%A6%AC%EA%B3%A0-combinereducers\" aria-label=\"redux의 action action creator reducer 그리고 combinereducers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Redux의 Action, Action Creator, Reducer 그리고 combineReducers</h3>\n<p>리덕스를 Flux 아키텍처의 구현체라고 하는데, 왜 그런지 조금은 알 것 같다. state를 변경하기 위해 action을 create하고 해당 action을 dispatch를 통해 reducer에게 발송한다.\n이를 받은 reducer는 action에 따라 업데이트된 state를 내놓게 되고 이를 통해 UI를 그린다. 이렇게 단방향 흐름인 Flux 아키텍처가 구현된다. 처음엔 왜 이런 흐름을 가져가야하나 했는데\n아직 코드가 짧아서 그런가… 굉장히 편한 것 같다. 이전에 진행했던 리액트 프로젝트들은 도대체 상태가 어떻게 흘러가는지 알기가 어려워서 추후에 리팩토링이나 디버깅하려면\n한참 cmd + 클릭으로 타고타고 가야했는데… 단방향 흐름을 잘 유지해주면 참 편리한 것 같다. 어떤 면에서는 TS를 처음 썼을 때 느낌이다. 앞에 준비할 게 많지만 잘 준비하면 그 뒤에는\n정말 편한 느낌..?!</p>\n<h3 id=\"세션과-쿠키\" style=\"position:relative;\"><a href=\"#%EC%84%B8%EC%85%98%EA%B3%BC-%EC%BF%A0%ED%82%A4\" aria-label=\"세션과 쿠키 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>세션과 쿠키</h3>\n<p>그 동안 그냥 단순하게 쿠키는 클라, 세션은 서버에 저장하는 사용자 정보 느낌으로만 알았다. 그리고 대충 클라에서 관리하니까 보안 상 좋지 않을 거 같고 서버에서 관리하니까 그나마\n보안에 유리하고… 그런데 이런 부분들말고도 쿠키와 세션의 라이프사이클이라든지, 전달 방법, 등장 이유(HTTP가 stateless하니까), 세션도 보통 쿠키를 같이 쓴다는 것 등등을 알게 된 게\n참 좋았다.</p>\n<h2 id=\"-오늘의-교훈\" style=\"position:relative;\"><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B5%90%ED%9B%88\" aria-label=\" 오늘의 교훈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🐾 오늘의 교훈</h2>\n<p>배워보자. 처음엔 두려운 것들도 막상 배워보면 그리 어렵지 않더라.</p>\n<h2 id=\"-참고\" style=\"position:relative;\"><a href=\"#-%EC%B0%B8%EA%B3%A0\" aria-label=\" 참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🪵 참고</h2>\n<ul>\n<li><a href=\"https://interconnection.tistory.com/74\">쿠키와 세션 개념</a></li>\n<li><a href=\"https://80000coding.oopy.io/1f213f10-185c-4b4e-8372-119402fecdd0\">로그인 인증 방식 어떤 게 좋을까? Session VS JWT</a></li>\n<li><a href=\"https://velog.io/@gwontaeyong/Session-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Stateless\">Session 그리고 Stateless</a></li>\n<li><a href=\"https://hyuntaeknote.tistory.com/6\">다중 서버 환경에서 Session은 어떻게 공유하고 관리할까?</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EC%84%B1%EC%9E%A5%EC%9D%BC%EC%A7%80-60\">🚤 성장일지 6.0</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B0%90%EC%A0%95\">🌈 오늘의 감정</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B3%A0%EB%AF%BC\">🫧 오늘의 고민</a></p>\n<ul>\n<li><a href=\"#%EA%B0%81%EA%B0%81%EC%9D%98-reducer%EC%97%90%EC%84%9C-%EC%B4%88%EA%B8%B0-%EC%83%81%ED%83%9C%EA%B0%92%EC%9D%84-%EC%A0%84%EB%8B%AC%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-combinereducers-%ED%9B%84%EC%97%90-createstore%ED%95%A0-%EB%95%8C-%EC%B4%88%EA%B8%B0-%EC%83%81%ED%83%9C%EB%A5%BC-%EC%A0%84%EB%8B%AC%ED%95%A0-%EC%88%98-%EC%97%86%EC%9D%84%EA%B9%8C\">각각의 reducer에서 초기 상태값을 전달하지 않고, combineReducers 후에 createStore할 때 초기 상태를 전달할 수 없을까?</a></li>\n<li><a href=\"#http%EC%9D%98-stateless-%EB%A9%B4%EC%97%90%EC%84%9C-%EB%B4%A4%EC%9D%84-%EB%95%8C-session-%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B0%A9%EC%8B%9D%EC%9D%80-%EC%A0%81%EC%A0%88%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%9C-%EA%B1%B0-%EC%95%84%EB%8B%8C%EA%B0%80\">HTTP의 stateless 면에서 봤을 때, session 기반의 방식은 적절하지 못한 거 아닌가?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B2%BD%ED%97%98\">☀️ 오늘의 경험</a></p>\n<ul>\n<li><a href=\"#redux%EC%9D%98-action-action-creator-reducer-%EA%B7%B8%EB%A6%AC%EA%B3%A0-combinereducers\">Redux의 Action, Action Creator, Reducer 그리고 combineReducers</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98%EA%B3%BC-%EC%BF%A0%ED%82%A4\">세션과 쿠키</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%98%A4%EB%8A%98%EC%9D%98-%EA%B5%90%ED%9B%88\">🐾 오늘의 교훈</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%B0%B8%EA%B3%A0\">🪵 참고</a></p>\n</li>\n</ul>\n</div>","frontmatter":{"date":"July 14, 2023","title":"230714(금)","categories":"성장일지","author":"제이든","emoji":"🌱"},"fields":{"slug":"/steadily/growth-diary/2023/7/14-gl/"}},"prev":{"id":"6d74997a-02c0-5fb8-a1f2-1fbecf4dc9ab","html":"<h2 id=\"-cs-network-스터디\" style=\"position:relative;\"><a href=\"#-cs-network-%EC%8A%A4%ED%84%B0%EB%94%94\" aria-label=\" cs network 스터디 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🧷 CS-Network 스터디</h2>\n<p>코드스쿼드 과정을 마치고 프론트엔드 개발자로서 알아야될 네트워크 지식을 채우기 위해 시작한 CS 스터디!<br/>\n<a href=\"https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md\">Tech-Interview-Network</a>를 참고하여 스터디를 진행하기로 했다.</p>\n<h1 id=\"2-http-응답코드에-대해-설명해-주세요\" style=\"position:relative;\"><a href=\"#2-http-%EC%9D%91%EB%8B%B5%EC%BD%94%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"2 http 응답코드에 대해 설명해 주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. HTTP 응답코드에 대해 설명해 주세요.</h1>\n<p>HTTP 응답코드는 HTTP 요청에 대한 응답으로 요청의 처리 상태를 알려주는 코드로 클라이언트와 서버 간의 HTTP 통신이 복잡해짐에 따라 이를 간다나게 표현하기 위해 만들어졌습니다. 100번부터 500번대로 크게 5가지의 응답을 코드로 나타냅니다.\n100번대는 <code class=\"language-text\">요청을 받아 작업을 진행 중</code>이라는 의미, 200번대는 <code class=\"language-text\">요청을 성공적으로 받았고 해당 요청을 성공적으로 완료했다</code>는 의미, 300번대는 <code class=\"language-text\">해당 요청을 완료하기 위해서는 다른 페이지로 리다이렉션 해야한다</code>는 의미, 400번대는 <code class=\"language-text\">클라이언트 측의 오류로, 요청 자체가 올바르지 않다</code>는 의미, 500번대는 <code class=\"language-text\">서버에서 오류가 생겨 요청을 처리할 수 없다</code>는 의미입니다. 일반적으로 통신이 성공했을 때, 200번 그리고 클라이언트 측의 요청 리소스가 서버에 존재하지 않을 때의 404번을 자주 볼 수 있습니다.</p>\n<h2 id=\"1-401-unauthorized-와-403-forbidden은-의미적으로-어떤-차이가-있나요\" style=\"position:relative;\"><a href=\"#1-401-unauthorized-%EC%99%80-403-forbidden%EC%9D%80-%EC%9D%98%EB%AF%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94\" aria-label=\"1 401 unauthorized 와 403 forbidden은 의미적으로 어떤 차이가 있나요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</h2>\n<p>401번은 사용자가 인증되지 않은 상태에서 특정 리소스에 접근할 때 발생하고 403번은 사용자가 인증되어있지만 해당 사용자에게는 부여되지 않은 권한에 접근할 때 발생합니다. 근본적으로 이 둘의 큰 차이는 현재 유저가 인증이 되어있느냐, 되어있지 않느냐입니다.</p>\n<h2 id=\"2-200-ok-와-201-created-의-차이에-대해-설명해-주세요\" style=\"position:relative;\"><a href=\"#2-200-ok-%EC%99%80-201-created-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"2 200 ok 와 201 created 의 차이에 대해 설명해 주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</h2>\n<p>200번은 클라이언트가 서버에게 요청한 작업이 성공적으로 수행되었음을 나타냅니다. 마찬가지로 201번도 클라이언트의 요청이 성공했다는 의미지만 좀더 나아가서 서버에 새로운 리소스가 생성되었음을 나타냅니다.그러므로 보통 POST, PUT 요청 성공에 대한 응답을 나타냅니다.</p>\n<h1 id=\"3-http-method-에-대해-설명해-주세요\" style=\"position:relative;\"><a href=\"#3-http-method-%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"3 http method 에 대해 설명해 주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. HTTP Method 에 대해 설명해 주세요.</h1>\n<p>HTTP 메서드는 클라이언트가 서버에 어떤 작업을 요청할지 즉, 어떤 종류의 요청인지를 나타냅니다.\n일반적으로 GET, POST, PUT, PATCH, DELETE 5가지의 메서드가 자주 사용됩니다.</p>\n<h2 id=\"1-http-method의-멱등성에-대해-설명해-주세요\" style=\"position:relative;\"><a href=\"#1-http-method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\" aria-label=\"1 http method의 멱등성에 대해 설명해 주세요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. HTTP Method의 멱등성에 대해 설명해 주세요.</h2>\n<p>멱등성은 특정 연산을 1번 한 것과 여러 번 진행한 것이 동일한 결과를 가지는 성질입니다. 즉, HTTP 메서드의 멱등성은 동일한 요청을 1번 보내는 것과 여러 번 보내는 것의 결과가 동일하다는 것을 의미합니다. 즉, 멱등성의 핵심은 ‘여러번 연산을 진행해도 상관없다.‘는 것에 있습니다.\n예를 들어 GET 메서드의 경우 1번 요청을 보내거나 여러 번 요청을 보내도 그 결과가 언제나 동일하므로 멱등성을 가집니다. 이렇게 멱등성을 갖는 대표적인 메서드는 GET, PUT, DELETE가 있습니다. 반대로 POST와 같이 1번 보내면 요청에 대해 어떤 데이터를 1번 생성하고 여러 번 보내면 어떤 데이터를 여러 번 생성하기 때문에 둘의 결과가 동일하지 않아 멱등하지 않습니다.\n추가로 데이터의 일부를 수정하는 PATCH의 경우, 요청의 조건에 따라 멱등 유무가 달라집니다. ‘어떤 유저의 이메일을 특저 이메일로 변경하는’ PATCH 요청의 경우, 1번 보내나 여러 번 보내나 동일한 이메일로 변경되므로 멱등합니다. 그렇지만 ‘특정 유저의 방문 횟수를 1씩 증가시키도록 변경하는’ PATCH 요청의 경우, 1번 보내는 것과 여러 번 보내는 것의 결과가 달라지므로 멱등하지 않게 됩니다.</p>\n<blockquote>\n<p>궁금증. POST가 아닌 GET으로도 데이터를 생성하는 경우도 있는 걸로 알고 있는데, 이런 경우 GET은 멱등성이 없어지는 게 아닌가?\n해결. GET으로도 서버에 데이터를 생성하는 게 불가능한 것은 아니다. 그렇지만 엄밀히 HTTP 프로토콜에서의 GET 메서드는 안전하고 멱등해야한다. 즉, 애초에 GET으로 데이터를 생성하는 요청을 보내는 것 자체가 HTTP 프로토콜의 원칙을 깬 것이다. 이렇게 되면 웹 스크랩핑, 웹 서버 로그 분석, 캐싱 등에서 문제가 발생할 수 있다.</p>\n</blockquote>\n<h2 id=\"2-get과-post의-차이는-무엇인가요\" style=\"position:relative;\"><a href=\"#2-get%EA%B3%BC-post%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"2 get과 post의 차이는 무엇인가요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. GET과 POST의 차이는 무엇인가요?</h2>\n<p>먼저 데이터를 전송하는 관점에서 말씀드리겠습니다.\nGET은 URL의 일부로 데이터를 전송하고 POST는 요청의 본문(body)으로 데이터를 전송합니다. 그렇기에 GET은 본문에 데이터가 노출되어 보안에 비교적 취약하다고 브라우저의 url 제한에 따른 데이터 크기 제한이 있다는 단점이 있습니다. 반면 POST는 요청의 본문에 데이터를 전송하기에 보안이 비교적 강하고 데이터 크기의 제한이 비교적 여유롭다는 장점이 있습니다.</p>\n<p>다음으로 안정성과 멱등성의 관점입니다.\nGET은 안정하고 멱등하기 때문에 여러 번 요청을 보내도 서버 혹은 DB의 상태를 변경시키지 않습니다. 반면, POST의 경우 요청에 따라 서버의 상태를 변경시키기 때문에 안정하고 멱등하지 않습니다.</p>\n<p>앞선 특징들에 따라 GET은 주로 데이터를 조회하는 데 사용되고 POST는 서버에 데이터를 전송하거나 서버의 상태를 변경하는데 사용합니다.</p>\n<h2 id=\"3-post와-put-patch의-차이는-무엇인가요\" style=\"position:relative;\"><a href=\"#3-post%EC%99%80-put-patch%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\" aria-label=\"3 post와 put patch의 차이는 무엇인가요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. POST와 PUT, PATCH의 차이는 무엇인가요?</h2>\n<p>3가지 메서드 모두 서버의 상태를 변경하는 데 사용됩니다.\n다만, POST는 주로 서버에 새로운 데이터를 생성할 때 사용됩니다. 즉, 멱등하지 않습니다.\nPUT은 기존의 데이터를 완전히 새로운 상태로 업데이트하거나 새로운 데이터를 생성하는 데 사용됩니다. PUT의 경우 멱등성을 가집니다.\nPATCH는 기존 데이터의 일부를 변경하는 데 사용되는 메서드로, 요청의 형태에 따라 멱등 유무가 달라집니다. ‘어떤 유저의 이메일을 특저 이메일로 변경하는’ PATCH 요청의 경우, 1번 보내나 여러 번 보내나 동일한 이메일로 변경되므로 멱등합니다. 그렇지만 ‘특정 유저의 방문 횟수를 1씩 증가시키도록 변경하는’ PATCH 요청의 경우, 1번 보내는 것과 여러 번 보내는 것의 결과가 달라지므로 멱등하지 않게 됩니다.</p>\n<h2 id=\"4-http-11-이후로-get에도-body에-데이터를-실을-수-있게-되었습니다-그럼에도-불구하고-왜-아직도-이런-방식을-지양하는-것일까요\" style=\"position:relative;\"><a href=\"#4-http-11-%EC%9D%B4%ED%9B%84%EB%A1%9C-get%EC%97%90%EB%8F%84-body%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%8B%A4%EC%9D%84-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EA%B7%B8%EB%9F%BC%EC%97%90%EB%8F%84-%EB%B6%88%EA%B5%AC%ED%95%98%EA%B3%A0-%EC%99%9C-%EC%95%84%EC%A7%81%EB%8F%84-%EC%9D%B4%EB%9F%B0-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C%EC%9A%94\" aria-label=\"4 http 11 이후로 get에도 body에 데이터를 실을 수 있게 되었습니다 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</h2>\n<p>HTTP는 응용 계층의 프로토콜로서 결국 하나의 약속이기 때문입니다. HTTP의 버전과는 상관없이 GET 메서드는 안정성과 멱등성을 유지해야합니다. 즉, 서버의 상태를 업데이트하면 HTTP라는 약속을 어기는 것이 됩니다. HTTP 1.1부터 명세의 일관성과 유연성을 위해 모든 HTTP 메서드가 요청 라인(request line), 헤더(header), 본문(body) 구조를 갖게 작성되었을 뿐, GET으로 body에 데이터를 담는 게 옳다는 것은 아닙니다.\n만약 데이터를 요청 본문(body)에 담아 GET 요청을 보내게 되면 웹 스크랩핑, 웹 서버 로그 분석, 캐싱 등에서 문제가 발생할 수 있습니다. 이를 해결하기 위해 많은 서버와 클라이언트 구현체는 본문(body)을 포함한 GET 요청을 무시하거나 오류를 반환하게 하고 있습니다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#-cs-network-%EC%8A%A4%ED%84%B0%EB%94%94\">🧷 CS-Network 스터디</a></li>\n<li><a href=\"#1-401-unauthorized-%EC%99%80-403-forbidden%EC%9D%80-%EC%9D%98%EB%AF%B8%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94\">1. 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?</a></li>\n<li><a href=\"#2-200-ok-%EC%99%80-201-created-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\">2. 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.</a></li>\n<li><a href=\"#1-http-method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94\">1. HTTP Method의 멱등성에 대해 설명해 주세요.</a></li>\n<li><a href=\"#2-get%EA%B3%BC-post%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">2. GET과 POST의 차이는 무엇인가요?</a></li>\n<li><a href=\"#3-post%EC%99%80-put-patch%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94\">3. POST와 PUT, PATCH의 차이는 무엇인가요?</a></li>\n<li><a href=\"#4-http-11-%EC%9D%B4%ED%9B%84%EB%A1%9C-get%EC%97%90%EB%8F%84-body%EC%97%90-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%8B%A4%EC%9D%84-%EC%88%98-%EC%9E%88%EA%B2%8C-%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EA%B7%B8%EB%9F%BC%EC%97%90%EB%8F%84-%EB%B6%88%EA%B5%AC%ED%95%98%EA%B3%A0-%EC%99%9C-%EC%95%84%EC%A7%81%EB%8F%84-%EC%9D%B4%EB%9F%B0-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C%EC%9A%94\">4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?</a></li>\n</ul>\n</div>","frontmatter":{"date":"July 17, 2023","title":"CS-Network. HTTP에 대해","categories":"스터디","author":"제이든","emoji":"🧷"},"fields":{"slug":"/from-time-to-time/study/cs-network/http/"}},"site":{"siteMetadata":{"siteUrl":"https://JaydenLee1116.github.io","comments":{"utterances":{"repo":"JaydenLee1116/JaydenLee1116.github.io"}}}}},"pageContext":{"slug":"/from-time-to-time/study/cs-network/cookie-session/","nextSlug":"/steadily/growth-diary/2023/7/14-gl/","prevSlug":"/from-time-to-time/study/cs-network/http/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}