{"componentChunkName":"component---src-templates-blog-template-js","path":"/from-time-to-time/study/in-depth-react/2-intro/","result":{"data":{"cur":{"id":"6ec1852b-9ef4-5513-b371-68f161acfaff","html":"<p>이 글은 스터디에서 <a href=\"https://goidle.github.io/react/in-depth-react-intro/\">리액트 톺아보기 2. Intro</a>를 읽고 정리하며 주관적으로 정리한 글입니다. 글을 읽고 핵심적이거나 더 깊게 보고 싶은 부분을 정리하였습니다. 원문보다 더 가독성이 좋지 못할(?) 수 있으니 원문도 읽어보시는 것을 추천드립니다.</p>\n<p>또한, 글을 읽고 이해한 내용을 바탕으로 작성한 글이기 때문에 틀린 내용이 있을 수 있습니다. 틀린 내용이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n<h1 id=\"️-리액트-톺아보기\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"️ 리액트 톺아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚛️ 리액트 톺아보기</h1>\n<h2 id=\"왜-code-classlanguage-text리액트-톺아보기code를-보는가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-code-classlanguage-text%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0code%EB%A5%BC-%EB%B3%B4%EB%8A%94%EA%B0%80\" aria-label=\"왜 code classlanguage text리액트 톺아보기code를 보는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 <code class=\"language-text\">리액트 톺아보기</code>를 보는가</h2>\n<p>Next.js를 통해 한층 더 추상화된 React를 사용하다보니, 아이러니하게도 React에 대한 더 깊은 이해가 필요하겠다는 갈증이 들었다. 리액트 공식문서도 혼자서 1번, 스터디에서 1번 읽었지만 뭐랄까… 전반적인 React의 컨셉과 api 사용법은 알겠으나 그 내부 구현에 대한 건 생각보다 깊이 있게 들어가기가 힘들었다. 그러던 중 <code class=\"language-text\">리액트 톺아보기</code> 글을 발견하였고 한국말로 정리된 글 중 가장 깊이있는 글이라고 생각하여 해당 글을 읽기로 했다! 부디 지금 내가 느끼는 리액트에 대한 갈증이 해결되었으면 좋겠다.</p>\n<p><img src=\"https://goidle.github.io/static/83aa2072b273a11e7b733979b439d735/ea64c/react-lifescycle.png\" alt=\"리액트 사이클\"></p>\n<h2 id=\"1-render-phase\" style=\"position:relative;\"><a href=\"#1-render-phase\" aria-label=\"1 render phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Render phase</h2>\n<ul>\n<li>\n<p>간단히 말하자면 <code class=\"language-text\">VDOM 조작 단계</code></p>\n</li>\n<li>\n<p>리액트는 element의 추가, 수정, 삭제와 같은 변경점이 생겼을 때, 이를 VDOM에 반영하는 과정을 거친다.</p>\n</li>\n<li>\n<p>이 때, <code class=\"language-text\">Work</code>를 담당하는 함수를 <code class=\"language-text\">scheduler</code>를 통해 실행시킨다.</p>\n<ul>\n<li>Work란 <code class=\"language-text\">reconciler</code>가 <code class=\"language-text\">컴포넌트의 변경을 DOM에 적용하기 위해 수행하는 작업</code>을 의미함. 이 Work를 통해 Render phase, Commit phase가 진행된다.</li>\n</ul>\n</li>\n<li>\n<p>Render phase는 VDOM을 재조정하는 일련의 과정을 말한다.</p>\n</li>\n<li>\n<p>재조정을 담당하는 <code class=\"language-text\">reconciler</code>의 설계가 <code class=\"language-text\">stack 기반에서 fiber기반으로 변경되면서</code> 해당 과정을 abort(중단), stop(일시정지), restart(재시작) 등의 기능을 제공할 수 있게 되었다.</p>\n</li>\n<li>\n<p>위의 기능은 <code class=\"language-text\">concurrent mode(동시 모드)</code>에서만 비동기와 함께 이루어지고 우리가 일반적으로 사용하는 mode(React.render())에서는 동기적으로 Render phase가 진행된다.</p>\n</li>\n</ul>\n<blockquote>\n<p>Concurrent란? (vs Parallel)<br/>\nConcurrent는 흔히 <code class=\"language-text\">동시성</code>, Parallel은 <code class=\"language-text\">병렬성</code>으로 표현된다. 둘의 차이는 <code class=\"language-text\">동시성은 하나의 코어에서 여러 작업을 번갈아가며 수행하는 것</code>을 의미하고, <code class=\"language-text\">병렬성은 여러 코어에서 여러 작업을 동시에 수행하는 것</code>을 의미한다. 즉, Concurrent는 <code class=\"language-text\">동시에 여러 작업을 수행하는 것처럼 보이는 것</code>을 의미한다.</p>\n</blockquote>\n<p>(Chat gpt)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">동시성(Concurrency)과 병렬성(Parallelism)은 두 가지 다른 개념으로, 프로그래밍 및 컴퓨터 시스템에서 중요한 역할을 합니다. 이 두 용어의 차이를 쉽게 설명하겠습니다:\n\n1. 동시성(Concurrency):\n   - 동시성은 여러 작업 또는 일련의 작업이 동시에 실행되는 것처럼 보이는 것을 의미합니다.\n   - 하나의 작업이 진행 중에 다른 작업이 일어날 수 있고, 작업들 간에 전환을 할 수 있습니다.\n   - 실제로는 하나의 CPU 코어에서 번갈아가며 여러 작업을 조금씩 처리합니다.\n   - 동시성은 주로 I/O 작업(예: 파일 읽기, 네트워크 요청)과 같이 대기 시간이 발생하는 작업을 효율적으로 처리하는 데 사용됩니다.\n\n2. 병렬성(Parallelism):\n   - 병렬성은 여러 작업이 동시에 실제로 독립적인 CPU 코어에서 실행되는 것을 의미합니다.\n   - 병렬적으로 실행되는 작업들은 동시에 진행되며, 독립적으로 실행되기 때문에 서로 영향을 주지 않습니다.\n   - 병렬성은 다중 코어 CPU 시스템에서 주로 발휘되며, 계산 집약적인 작업(예: 병렬 계산, 렌더링)을 효율적으로 처리하는 데 사용됩니다.\n\n간단히 말하면, 동시성은 여러 작업을 번갈아가며 처리하면서 전환할 수 있는 것을 의미하며, 병렬성은 독립적으로 실행되는 작업을 동시에 처리하는 것을 의미합니다. 이 두 가지 개념은 작업 처리 방식과 하드웨어 환경에 따라 다르게 적용되며, 특정 문제를 효율적으로 해결하기 위해 선택됩니다.</code></pre></div>\n<p>(추가) 현재 리액트 18버전을 기준으로는 concurrent mode라는 mode는 따로 존재하지 않는다. 대신 concurrent features(동시 기능들)을 기본적으로 제공한다.</p>\n<ul>\n<li>\n<ol>\n<li>Concurrent Mode(동시성 모드): Concurrent Features의 핵심입니다. 이 모드에서 리액트는 렌더링 작업을 여러 단계로 나누어 처리하여 더 빠른 렌더링과 반응성을 제공합니다. 예를 들어, 렌더링 작업이 진행 중일 때에도 우선순위가 낮은 다른 작업(예: 사용자 입력 처리)이 중단되지 않고 실행됩니다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>Suspense(중단): Suspense는 데이터 로딩 및 코드 분할과 같은 비동기 작업을 처리할 때 사용됩니다. 리액트 18에서는 Suspense를 사용하여 데이터를 미리 로딩하고 로딩이 완료될 때까지 대기하거나 대체 컨텐츠를 표시할 수 있습니다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>Error Boundaries(에러 경계): Concurrent Mode에서는 Error Boundaries가 더욱 강화되었습니다. 에러 경계는 컴포넌트 내에서 발생하는 예외를 캐치하고 처리할 수 있도록 도와줍니다. 이를 통해 애플리케이션의 안정성을 향상시킬 수 있습니다.</li>\n</ol>\n</li>\n<li>\n<ol start=\"4\">\n<li>React Server Components: 이것은 리액트 18에서 실험적으로 도입된 기능 중 하나로, 서버 측에서 렌더링되는 컴포넌트를 관리하고 클라이언트와 협력하여 더 나은 성능을 제공합니다.</li>\n</ol>\n</li>\n</ul>\n<p>즉, 위와 같이 concurrent features를 통해서 애플리케이션의 성능과 사용자 경험을 향상시킬 수 있다. 비동기 데이터 로딩, 코드 분할이나 렌더링 중단과 같은 복잡한 작업을 효율적으로 처리할 수 있게 도와준다. 또한 이런 기능들은 개발자 경험 또한 향상시킬 수 있다.(예를 들어 useEffect로 데이터를 fetch 해와서 state로 변경한 뒤에 렌더링을 해야만 했던 걸 Suspense와 같은 기능을 사용해서 해결한다든지!)</p>\n<ul>\n<li>1편에서 말했듯 <code class=\"language-text\">컴포넌트 호출</code>은 <code class=\"language-text\">Render phase</code>에서 실행이 되고 호출은 화면 반영을 나타내는 것이 아님</li>\n<li>1편에서 말했던 <code class=\"language-text\">렌더링</code>에 빗대어 설명하면 <code class=\"language-text\">컴포넌트가 렌더링 혹은 리렌더링된다</code>는 것은 <code class=\"language-text\">컴포넌트가 호출되어 VDOM에 반영된다</code>는 것을 의미한다. 즉, DOM에 마운트되어 페인트된다는 의미가 아니다!</li>\n</ul>\n<h2 id=\"2-commit-phase\" style=\"position:relative;\"><a href=\"#2-commit-phase\" aria-label=\"2 commit phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Commit phase</h2>\n<ul>\n<li>간단히 말하자면 <code class=\"language-text\">재조정된 VDOM을 DOM에 적용하고 라이프 사이클을 실행하는 단계</code>\n<ul>\n<li>VDOM이 DOM에 적용되는 것이지 페인트가 되는 것이 아니다!</li>\n</ul>\n</li>\n<li>항상 일관적인 화면 업데이트를 위해서 동기적으로 실행된다.</li>\n<li>동기적으로 실행된다는 의미는 콜스택을 한 번도 비우지 않고 DOM 조작을 처리한다는 의미이다.</li>\n<li>즉, Commit phase 중간에 페인트가 일어나지 않는다. 페인트는 Commit phase가 끝난 뒤 콜스택을 비워야지만 브라우저에서 화면을 페인트할 수 있게 된다.</li>\n</ul>\n<p>(Chat GPT): Mount와 Commit은 동일한 건가?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">리액트에서 \"mount\"와 \"commit\"은 서로 다른 단계를 나타냅니다. 이 두 개념은 React 컴포넌트의 라이프사이클과 렌더링 프로세스에서 발생하는 다른 시점을 나타냅니다.\n\n1. Mount(마운트):\n   - \"마운트\"는 React 컴포넌트가 처음으로 생성되고 DOM에 삽입되는 시점을 가리킵니다.\n   - 컴포넌트의 생명주기(Lifecycle) 메서드 중 `componentDidMount`가 이 시점에 호출됩니다.\n   - 주로 초기화 작업 및 외부 데이터 로딩과 같은 작업을 수행합니다.\n   - 사용자에게 보여지기 직전에 발생하므로, 컴포넌트가 실제로 화면에 표시되기 전에 실행됩니다.\n\n2. Commit(커밋):\n   - \"커밋\"은 Virtual DOM의 재조정 결과를 실제 DOM에 적용하고 라이프사이클 메서드를 실행하는 단계를 가리킵니다.\n   - 재조정된 Virtual DOM의 변경 사항을 실제 DOM에 반영하고, 이후 라이프사이클 메서드 중 `componentDidUpdate`가 호출됩니다.\n   - 주로 업데이트와 관련된 작업을 수행하며, 컴포넌트가 화면에 이미 표시되어 있을 때 호출됩니다.\n   - 컴포넌트의 상태나 속성이 변경될 때마다 발생합니다.\n\n요약하면, \"마운트\"와 \"커밋\"은 React 컴포넌트 라이프사이클에서 서로 다른 시점에 발생하는 단계입니다. \"마운트\"는 컴포넌트가 처음으로 생성되고 화면에 표시되는 시점에 관련되며, \"커밋\"은 컴포넌트가 이미 화면에 표시되어 있는 상태에서 상태나 속성이 변경되어 재조정 및 업데이트가 필요한 시점에 관련됩니다.</code></pre></div>\n<h2 id=\"3-vdomvirtual-dom\" style=\"position:relative;\"><a href=\"#3-vdomvirtual-dom\" aria-label=\"3 vdomvirtual dom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. VDOM(Virtual DOM)</h2>\n<p><img src=\"https://goidle.github.io/static/258b43ce623e7b6340fc6aed969199ed/374ac/vDOM.png\" alt=\"VDOM\"></p>\n<blockquote>\n<p>current tree와 workInProgress tree의 최상단 노드는 엄밀히 Host root node라고 부른다.</p>\n</blockquote>\n<ul>\n<li>앞에서 이야기 했듯이 리액트는 VDOM을 더블 버퍼링 형태로 관리한다.\n<ul>\n<li>current tree: 현재 DOM에 마운트되어 있는 tree</li>\n<li>workInProgress tree: 현재 변경 중인 tree 즉, Render phase에서 작업중인 tree\n<ul>\n<li>이 tree가 Commit phase를 지나 (DOM에 적용되면) current tree가 된다.</li>\n</ul>\n</li>\n<li>더블 버퍼링 형태로 관리하는 이유는 변경 중인 tree가 완성되기 전까지는 사용자에게 보여주지 않기 위함이다.\n<ul>\n<li>workInProgress에 작업을 하다가도 언제든지 중단하고 다시 작업하거나 중지시켰다가 다시 시작할 수 있다.</li>\n<li>즉, 변경 중인 tree가 완성되기 전까지는 사용자에게 보여주지 않는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>workInProgress tree는 current tree에서 자기 복제하여 서로를 alternate로 참조하는 방식이다.</li>\n<li><code class=\"language-text\">VDOM 노드</code>(이게 바로 <code class=\"language-text\">fiber</code>)는 자식을 first child만 참조한다. 그리고 나머지 자식들은 이 first child가 sibling으로 참조하고 있다.</li>\n<li>모든 자식 노드는 부모를 return으로 참조하고 있다.(<code class=\"language-text\">진짜 자식 fiber의 return이라는 속성이 부모 fiber를 참조한다는 의미</code>)</li>\n</ul>\n<p>(Chat GPT): current tree와 workInProgress tree의 복제는 얕은 복사? 깊은 복사?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\"workInProgress\"가 \"current\"를 복제할 때, 실제로는 얕은 복사(Shallow Copy)를 사용합니다. 얕은 복사는 객체의 내부 구조를 완전히 복사하지 않고 참조만을 복제하는 방식입니다. 이것은 메모리 효율적이며 빠르게 복사할 수 있습니다.\n\n실제로 \"workInProgress\"와 \"current\"는 가상 DOM의 구조를 공유하면서, 변경 사항만을 반영합니다. 이렇게 하면 메모리 사용량을 줄이고 렌더링 프로세스를 빠르게 처리할 수 있습니다.\n\n얕은 복사를 사용하므로, \"workInProgress\"의 변경 사항이 \"current\"에 영향을 주게 되면서 두 구조가 서로 \"alternate\"로 교체되는 방식으로 작동합니다. 이러한 동작은 리액트의 효율적인 업데이트와 렌더링을 가능하게 합니다.</code></pre></div>\n<blockquote>\n<p>흠… 그런데 어떻게 변경 사항을 workInProgress에서만 반영하고 current에는 아직 반영하지 않을 수 있지..? 동일한 노드를 참조하고 있으면 동일한 메모리를 참조하는 거고 그러면 current에도 반영되지 않을까? 🤔 구글링, 지피팅을 해봐도 명확한 답이 안나온다… 좀더 해외 자료를 찾아보는 게 좋겠다.</p>\n</blockquote>\n<h2 id=\"4-react-element\" style=\"position:relative;\"><a href=\"#4-react-element\" aria-label=\"4 react element permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. React element</h2>\n<ul>\n<li>React element는 컴포넌트의 정보를 담고 있는 모델 객체</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> content <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>content<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App key<span class=\"token operator\">=</span><span class=\"token string\">\"1\"</span> content<span class=\"token operator\">=</span><span class=\"token string\">\"Deep dive react\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> container<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// React element를 고유하게 식별할 수 있도록 해주는 태그</span>\n  $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 리액트에서 자체적으로 제공하는 속성</span>\n  <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> type<span class=\"token punctuation\">,</span> <span class=\"token comment\">// function App()</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> key<span class=\"token punctuation\">,</span> <span class=\"token comment\">// 1</span>\n  <span class=\"token literal-property property\">props</span><span class=\"token operator\">:</span> props<span class=\"token punctuation\">,</span> <span class=\"token comment\">// { content: 'deep dive react' }</span>\n  <span class=\"token literal-property property\">ref</span><span class=\"token operator\">:</span> ref<span class=\"token punctuation\">,</span> <span class=\"token comment\">// undefined</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>우리가 return하는 <code class=\"language-text\">JSX</code>는 <code class=\"language-text\">React element</code>가 아니라 <code class=\"language-text\">React element</code>를 반환하는 <code class=\"language-text\">함수</code>이다.\n<ul>\n<li>즉, <code class=\"language-text\">JSX</code> => <code class=\"language-text\">react.createElement()</code> => <code class=\"language-text\">React element</code> 의 과정을 거친다.</li>\n<li>type에는 컴포넌트의 종류에 따라 다른 값이 사용되는데, 호스트 컴포넌트는 문자열(tag 이름 ex. div, span, button…), 커스텀 컴포넌트는 함수 자체가 사용된다.</li>\n<li>JSX를 통해 트개의 attribute를 전달할 때 key, ref는 props에 포함되지 않는다.(나머지는 props로 관리한다.)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"5-fiber\" style=\"position:relative;\"><a href=\"#5-fiber\" aria-label=\"5 fiber permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. Fiber</h2>\n<ul>\n<li>자, 이제 위에서 반환된 React element를 VDOM에 올려야하는데, 그 확장을 <code class=\"language-text\">fiber</code>가 한다.</li>\n<li>즉, <code class=\"language-text\">fiber</code>는 <code class=\"language-text\">VDOM의 노드 객체</code>이며 컴포넌트가 살아 숨쉬기 위해 모든 정보를 관리하고 있다!!!</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react-reconciler > ReactFiber.js</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">FiberNode</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">tag<span class=\"token punctuation\">,</span> pendingProps<span class=\"token punctuation\">,</span> key</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Instance</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>tag <span class=\"token operator\">=</span> tag<span class=\"token punctuation\">;</span> <span class=\"token comment\">// fiber의 종류를 나타냄</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>key <span class=\"token operator\">=</span> key<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>type <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 추후에 React element의 type을 저장</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>stateNode <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 호스트 컴포넌트에 대응되는 HTML element를 저장</span>\n\n  <span class=\"token comment\">// Fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>return <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 부모 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 자식 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>sibling <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 형제 fiber</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>index <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 형제들 사이에서의 자신의 위치</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>pendingProps <span class=\"token operator\">=</span> pendingProps<span class=\"token punctuation\">;</span> <span class=\"token comment\">// workInProgress는 아직 작업이 끝난 상태가 아니므로 props를 pending으로 관리</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>memoizedProps <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Render phase가 끝나면 pendingProps는 memoizedProps로 관리</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>updateQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트 종류에 따라 element의 변경점 또는 라이프사이클을 저장</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 함수형 컴포넌트는 훅을 통해 상태를 관리하므로 hook 리스트가 저장된다.</span>\n\n  <span class=\"token comment\">// Effects</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>effectTag <span class=\"token operator\">=</span> NoEffect<span class=\"token punctuation\">;</span> <span class=\"token comment\">// fiber가 가지고 있는 side effect를 기록</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// side effect list</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// side effect list</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// side effect list</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">=</span> NoWork<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 컴포넌트 업데이트 발생 시간을 기록</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>childExpirationTime <span class=\"token operator\">=</span> NoWork<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 서브 트리에서 업데이트가 발생할 경우 기록</span>\n\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>alternate <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 반대편 fiber를 참조</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(추가) 궁금해서 React 16.3 버전의 패키지를 찾아봤다. <a href=\"https://github.com/facebook/react/blob/16.3-dev/packages/react-reconciler/src/ReactFiber.js\">참고 - Fiber</a></p>\n<p>그리고 아래의 경로에서 Fiber의 type을 확인할 수 있었다. 해당 type에 달려있는 주석을 간단하게 번역해보았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// react/packages/react-reconciler/src/ReactFiber.js</span>\n\n<span class=\"token comment\">// Fiber는 컴포넌트에서 수행해야 할 작업 또는 수행된 작업이다. 컴포넌트 당 하나 이상의 Fiber가 있을 수 있다.</span>\n<span class=\"token keyword\">export</span> type Fiber <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token operator\">|</span>\n  <span class=\"token comment\">// 이 첫 번째 필드들은 개념적으로 Instance의 멤버이다. 이것은 이전에 별도의 타입으로 분리되어 다른 Fiber 필드와 교차되었지만, Flow가 교차 버그를 수정할 때까지 하나의 타입으로 병합했다.</span>\n\n  <span class=\"token comment\">// Instance는 컴포넌트의 모든 버전에서 공유된다. 우리는 이것을 별도의 객체로 쉽게 분리할 수 있다. 트리의 대체 버전에 너무 많은 복사를 피하기 위해. 우리는 초기 렌더링 중에 생성되는 객체의 수를 최소화하기 위해 일단 하나의 객체에 넣었다.</span>\n\n  <span class=\"token comment\">// fiber의 종류 식별자</span>\n  <span class=\"token literal-property property\">tag</span><span class=\"token operator\">:</span> WorkTag<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 이 child의 고유 식별자</span>\n  <span class=\"token literal-property property\">key</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> string<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 이 child의 reconciliation 중에 identity를 보존하는 데 사용되는 element.type의 값</span>\n  <span class=\"token literal-property property\">elementType</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 이 fiber와 연관된 함수/클래스</span>\n  <span class=\"token literal-property property\">type</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 번역: 이 fiber와 연관된 local state</span>\n  <span class=\"token literal-property property\">stateNode</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Conceptual aliases</span>\n  <span class=\"token comment\">// 부모는 Instance -> return이다. 우리는 fiber와 instance를 병합했기 때문에 부모는 return fiber와 동일하다</span>\n\n  <span class=\"token comment\">// 나머지 필드는 Fiber에 속한다.</span>\n\n  <span class=\"token comment\">// 이것을 처리한 후에 반환할 Fiber</span>\n  <span class=\"token comment\">// 이것은 사실상 부모이지만, 부모가 여러 개(두 개)일 수 있다</span>\n  <span class=\"token comment\">// 그래서 이것은 우리가 현재 처리하고 있는 것의 부모에 불과하다</span>\n  <span class=\"token comment\">// 이것은 개념적으로 스택 프레임의 반환 주소와 동일하다</span>\n  <span class=\"token keyword\">return</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 단일 연결 리스트 트리 구조 => 위에서 설명한 구조네!!!</span>\n  <span class=\"token literal-property property\">child</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">sibling</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">index</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// 여기서부턴 번역 생략... 영어로 보는 게 더 좋을 것 같다.</span>\n\n  <span class=\"token comment\">// The ref last used to attach this node.</span>\n  <span class=\"token comment\">// I'll avoid adding an owner field for prod and model that as functions.</span>\n  <span class=\"token literal-property property\">ref</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">handle</span><span class=\"token operator\">:</span> mixed</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">_stringRef</span><span class=\"token operator\">:</span> <span class=\"token operator\">?</span>string <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> RefObject<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Input is the data coming into process this fiber. Arguments. Props.</span>\n  <span class=\"token literal-property property\">pendingProps</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span> <span class=\"token comment\">// This type will be more specific once we overload the tag.</span>\n  <span class=\"token literal-property property\">memoizedProps</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span> <span class=\"token comment\">// The props used to create the output.</span>\n\n  <span class=\"token comment\">// A queue of state updates and callbacks.</span>\n  <span class=\"token literal-property property\">updateQueue</span><span class=\"token operator\">:</span> UpdateQueue<span class=\"token operator\">&lt;</span>any<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// The state used to create the output</span>\n  <span class=\"token literal-property property\">memoizedState</span><span class=\"token operator\">:</span> any<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// A linked-list of contexts that this fiber depends on</span>\n  <span class=\"token literal-property property\">firstContextDependency</span><span class=\"token operator\">:</span> ContextDependency<span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Bitfield that describes properties about the fiber and its subtree. E.g.</span>\n  <span class=\"token comment\">// the ConcurrentMode flag indicates whether the subtree should be async-by-</span>\n  <span class=\"token comment\">// default. When a fiber is created, it inherits the mode of its</span>\n  <span class=\"token comment\">// parent. Additional flags can be set at creation time, but after that the</span>\n  <span class=\"token comment\">// value should remain unchanged throughout the fiber's lifetime, particularly</span>\n  <span class=\"token comment\">// before its child fibers are created.</span>\n  <span class=\"token literal-property property\">mode</span><span class=\"token operator\">:</span> TypeOfMode<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Effect</span>\n  <span class=\"token literal-property property\">effectTag</span><span class=\"token operator\">:</span> SideEffectTag<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Singly linked list fast path to the next fiber with side-effects.</span>\n  <span class=\"token literal-property property\">nextEffect</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// The first and last fiber with side-effect within this subtree. This allows</span>\n  <span class=\"token comment\">// us to reuse a slice of the linked list when we reuse the work done within</span>\n  <span class=\"token comment\">// this fiber.</span>\n  <span class=\"token literal-property property\">firstEffect</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  <span class=\"token literal-property property\">lastEffect</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Represents a time in the future by which this work should be completed.</span>\n  <span class=\"token comment\">// Does not include work found in its subtree.</span>\n  <span class=\"token literal-property property\">expirationTime</span><span class=\"token operator\">:</span> ExpirationTime<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// This is used to quickly determine if a subtree has no pending changes.</span>\n  <span class=\"token literal-property property\">childExpirationTime</span><span class=\"token operator\">:</span> ExpirationTime<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// This is a pooled version of a Fiber. Every fiber that gets updated will</span>\n  <span class=\"token comment\">// eventually have a pair. There are cases when we can clean up pairs to save</span>\n  <span class=\"token comment\">// memory if we need to.</span>\n  <span class=\"token literal-property property\">alternate</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Time spent rendering this Fiber and its descendants for the current update.</span>\n  <span class=\"token comment\">// This tells us how well the tree makes use of sCU for memoization.</span>\n  <span class=\"token comment\">// It is reset to 0 each time we render and only updated when we don't bailout.</span>\n  <span class=\"token comment\">// This field is only set when the enableProfilerTimer flag is enabled.</span>\n  actualDuration<span class=\"token operator\">?</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// If the Fiber is currently active in the \"render\" phase,</span>\n  <span class=\"token comment\">// This marks the time at which the work began.</span>\n  <span class=\"token comment\">// This field is only set when the enableProfilerTimer flag is enabled.</span>\n  actualStartTime<span class=\"token operator\">?</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Duration of the most recent render time for this Fiber.</span>\n  <span class=\"token comment\">// This value is not updated when we bailout for memoization purposes.</span>\n  <span class=\"token comment\">// This field is only set when the enableProfilerTimer flag is enabled.</span>\n  selfBaseDuration<span class=\"token operator\">?</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Sum of base times for all descedents of this Fiber.</span>\n  <span class=\"token comment\">// This value bubbles up during the \"complete\" phase.</span>\n  <span class=\"token comment\">// This field is only set when the enableProfilerTimer flag is enabled.</span>\n  treeBaseDuration<span class=\"token operator\">?</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n\n  <span class=\"token comment\">// Conceptual aliases</span>\n  <span class=\"token comment\">// workInProgress : Fiber ->  alternate The alternate used for reuse happens</span>\n  <span class=\"token comment\">// to be the same as work in progress.</span>\n  <span class=\"token comment\">// __DEV__ only</span>\n  _debugID<span class=\"token operator\">?</span><span class=\"token operator\">:</span> number<span class=\"token punctuation\">,</span>\n  _debugSource<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Source <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  _debugOwner<span class=\"token operator\">?</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  _debugIsCurrentlyTiming<span class=\"token operator\">?</span><span class=\"token operator\">:</span> boolean<span class=\"token punctuation\">,</span>\n<span class=\"token operator\">|</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"6-side-effect\" style=\"position:relative;\"><a href=\"#6-side-effect\" aria-label=\"6 side effect permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. Side effect</h2>\n<ul>\n<li>VDOM에서 변경점(추가, 수정, 삭제 등)을 만들거나 만들어낼 수도 있는 작업(라이프 사이클)을 의미</li>\n<li>아래는 리액트에서 사용되는 side effect tag</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// shared > ReactSideEffectTags.js</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> NoEffect <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>                <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PerformedWork <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>           <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000000001</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Placement <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>               <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000000010</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Update <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>                  <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000000100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PlacementAndUpdate <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>      <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000000110</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Deletion <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>                <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000001000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ContentReset <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>            <span class=\"token operator\">/</span> <span class=\"token number\">0b0000000010000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Passive <span class=\"token operator\">=</span> <span class=\"token operator\">/</span>                 <span class=\"token operator\">/</span> <span class=\"token number\">0b0001000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">/*...*/</span></code></pre></div>\n<p>이것도 궁금해서 직접 들어가봤다. <a href=\"https://github.com/facebook/react/blob/16.3-dev/packages/shared/ReactSideEffectTags.js\">참고 Side effect tags</a></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">export</span> type SideEffectTag <span class=\"token operator\">=</span> number<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Don't change these two values. They're used by React Dev Tools.</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> NoEffect <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b000000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PerformedWork <span class=\"token operator\">=</span> <span class=\"token comment\">/*         */</span> <span class=\"token number\">0b000000000001</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// You can change the rest (and add more).</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Placement <span class=\"token operator\">=</span> <span class=\"token comment\">/*             */</span> <span class=\"token number\">0b000000000010</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Update <span class=\"token operator\">=</span> <span class=\"token comment\">/*                */</span> <span class=\"token number\">0b000000000100</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PlacementAndUpdate <span class=\"token operator\">=</span> <span class=\"token comment\">/*    */</span> <span class=\"token number\">0b000000000110</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Deletion <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b000000001000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ContentReset <span class=\"token operator\">=</span> <span class=\"token comment\">/*          */</span> <span class=\"token number\">0b000000010000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Callback <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b000000100000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> DidCapture <span class=\"token operator\">=</span> <span class=\"token comment\">/*            */</span> <span class=\"token number\">0b000001000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Ref <span class=\"token operator\">=</span> <span class=\"token comment\">/*                   */</span> <span class=\"token number\">0b000010000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Snapshot <span class=\"token operator\">=</span> <span class=\"token comment\">/*              */</span> <span class=\"token number\">0b000100000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Passive <span class=\"token operator\">=</span> <span class=\"token comment\">/*               */</span> <span class=\"token number\">0b001000000000</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> LifecycleEffectMask <span class=\"token operator\">=</span> <span class=\"token comment\">/*   */</span> <span class=\"token number\">0b001110100100</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Union of all host effects</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> HostEffectMask <span class=\"token operator\">=</span> <span class=\"token comment\">/*        */</span> <span class=\"token number\">0b001111111111</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Incomplete <span class=\"token operator\">=</span> <span class=\"token comment\">/*            */</span> <span class=\"token number\">0b010000000000</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> ShouldCapture <span class=\"token operator\">=</span> <span class=\"token comment\">/*         */</span> <span class=\"token number\">0b100000000000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>(Chat GPT) 흠… 근데 왜 굳이 이진수로 표현했을까..?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">리액트 소스 코드에서 side effect (부수 효과) 태그를 이진수로 표현하는 이유는 성능 및 메모리 최적화와 관련이 있습니다. 이진수로 표현함으로써 비트 단위로 각 태그를 활성화 또는 비활성화할 수 있으므로, 메모리 사용을 최적화하고 연산을 빠르게 수행할 수 있습니다.\n\n여기에 몇 가지 이유와 장점이 있습니다:\n\n메모리 최적화: 이진수 표현을 사용하면 각 태그가 메모리에서 고정된 크기를 차지합니다. 이는 리액트가 메모리를 효율적으로 관리할 수 있도록 도와줍니다.\n\n비트 연산의 효율성: 이진수로 표현된 값을 비트 단위로 검사하고 조작할 수 있습니다. 예를 들어, 여러 태그를 병합하거나 필터링하는 등의 작업을 빠르게 수행할 수 있습니다.\n\n디버깅 및 툴 지원: 개발자 도구와 같은 도구들이 이진수로 표현된 값을 해석하고 시각적으로 표현할 수 있습니다. 예를 들어, 이진수 플래그를 디버깅 시에 쉽게 추적하고 이해할 수 있습니다.\n\n확장성: 새로운 태그가 추가될 때 이진수로 표현된 값을 확장하기가 비교적 쉽습니다. 비트 단위로 조작하므로 새로운 태그를 추가하는 데 비교적 적은 노력이 필요합니다.\n\n이진수 표현은 리액트 내부에서 side effect를 효과적으로 관리하고 최적화하는 데 도움을 주는 중요한 기술적 결정 중 하나입니다.</code></pre></div>\n<ul>\n<li>(다시 돌아와서) 이 tag 값들은 fiber의 <code class=\"language-text\">effectTag</code>에 저장된다.</li>\n<li>해당 tag(위의 tag들)가 달린 fiber는 effect로 취급되어 연결 리스트의 상위로 엮어져 올라가게 된다.</li>\n<li>최종적으로 최상위 fiber가 하위의 모든 effect를 가지고 있게 되어 Commit phase에서 이를 처리하게 된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 자식의 side effect를 부모로 올린다.</span>\n<span class=\"token comment\">// returnFiber: 부모 fiber, workInProgress: 자식 fiber</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>firstEffect<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>firstEffect<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 자신에게도 side effect가 있다면 자기 자신도 effect list에 추가해준다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>effectTag <span class=\"token operator\">></span> PerformedWork<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>lastEffect<span class=\"token punctuation\">.</span>nextEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    returnFiber<span class=\"token punctuation\">.</span>firstEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  returnFiber<span class=\"token punctuation\">.</span>lastEffect <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>위의 로직 순서를 보면 알 수 있듯이 effect list는 자식의 effect list를 부모의 effect list에 연결하는 방식으로 구현되어 있다. 이 때, 자식을 먼저 연결한 뒤에 자신을 연결하는 이유는 자식의 effect list가 부모의 effect list보다 먼저 처리되어야 하기 때문이다. 즉, 부모의 effect list는 자식의 effect list보다 나중에 처리되어야 한다. (부모의 effect list가 먼저 처리되면 자식의 effect list가 처리되지 않은 상태에서 부모의 effect list에 의해 DOM이 변경되어 버린다.) 즉, DFS 방식으로 처리되는 것이다.<br/>\n위의 과정은 Commit phase에서 일어나는 일이다. 이 때, effect list는 side effect를 처리하는 순서를 나타낸다. 즉, effect list의 순서는 side effect의 처리 순서를 나타낸다.</p>\n</blockquote>\n<h2 id=\"7-bit-masking\" style=\"position:relative;\"><a href=\"#7-bit-masking\" aria-label=\"7 bit masking permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. Bit Masking</h2>\n<ul>\n<li>비트 마스킹은 비트 연산을 통해 특정 비트를 0 또는 1로 설정하는 기법을 의미한다.</li>\n<li>리액트에선느 effect tag, 여러 상태 값들을 비트 마스킹을 통해 관리한다.</li>\n<li>현재 실행되고 있는 환경을 나타내는 <code class=\"language-text\">context</code> 또한 비트 마스킹을 통해 관리한다.\n<ul>\n<li>render context: 16 즉, 10000 => 5번째 자리가 1이면 Render phase에서 실행 중</li>\n<li>commit context: 32 즉, 100000 => 6번째 자리가 1이면 Commit phase에서 실행 중</li>\n</ul>\n</li>\n</ul>\n<p>이렇게 비트 마스킹을 하는 이유는 비트 연산자를 통해서 특정 비트가 0인지 1인지 확인할 수 있기 때문이다.</p>\n<ul>\n<li>상태값 확인: and(&#x26;) 연산자를 통해 특정 비트가 0인지 1인지 확인할 수 있다.</li>\n<li>상태값 설정: or(|) 연산자를 통해 특정 비트를 0 또는 1로 설정할 수 있다.</li>\n<li>상태값 제거: xor(~) 연산자를 통해 특정 비트를 0으로 설정할 수 있다.</li>\n</ul>\n<p>예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> NoContext <span class=\"token operator\">=</span> <span class=\"token number\">0b00</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> RenderContext <span class=\"token operator\">=</span> <span class=\"token number\">0b01</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> CommitContext <span class=\"token operator\">=</span> <span class=\"token number\">0b10</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> executionContext <span class=\"token operator\">=</span> NoContext<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0</span>\n\n<span class=\"token comment\">// Render phase에서 접어들어 현재 context를 render context로 설정</span>\nexecutionContext <span class=\"token operator\">|=</span> RenderContext<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 00 | 01 => 01</span>\n\n<span class=\"token comment\">// 현재 context에 따라 분기처리</span>\n<span class=\"token comment\">// executionContext를 특정 context와 and 처리했을 때, NoContext가 아니라면 특정 context라는 의미!</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>RenderContext <span class=\"token operator\">!==</span> NoContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Render phase</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>CommitContext <span class=\"token operator\">!==</span> NoContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Commit phase</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Render phase가 끝나고 Commit phase에 접어들면 이전 context를 지우고 다음 context를 설정</span>\nexecutionContext <span class=\"token operator\">&amp;=</span> <span class=\"token operator\">~</span>RenderContext<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 01 &amp; ~01 => 00</span>\nexecutionContext <span class=\"token operator\">|=</span> CommitContext<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 00 | 10 => 10</span>\n\n<span class=\"token comment\">// 리액트에서의 실제 사용 사례</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>executionContext <span class=\"token operator\">&amp;</span> <span class=\"token punctuation\">(</span>RenderContext <span class=\"token operator\">|</span> CommitContext<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> NoContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">//현재 context가 Render phase이거나 Commit phase이면</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">msToExpirationTime</span><span class=\"token punctuation\">(</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h1 id=\"후기\" style=\"position:relative;\"><a href=\"#%ED%9B%84%EA%B8%B0\" aria-label=\"후기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>후기…</h1>\n<p>미쳤다… 이걸 안다고 해서 리액트 코드를 잘 짤 수 있는 건 아니지만, 이전에는 리액트가 정말 단순하게 옵저버 패턴과 클로저로 구현되어있다… 는 정도만 추상적으로 머리에 있었는데!!!!!! 와… 쉬운 내용은 아니지만 하나하나 열심히 까보니까 정말 재미있고 도움이 많이 된다!!!!!!</p>\n<h1 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h1>\n<ul>\n<li><a href=\"https://goidle.github.io/react/in-depth-react-intro/\">리액트 톺아보기 2. Intro</a></li>\n<li><a href=\"https://m.blog.naver.com/jjoommnn/130036290769\">Concurrent vs Parallel</a></li>\n<li><a href=\"https://github.com/facebook/react/tree/16.3-dev/packages\">React v16.3.0 packages</a></li>\n<li><a href=\"https://github.com/facebook/react/blob/16.3-dev/packages/react-reconciler/src/ReactFiber.js\">참고 - Fiber</a></li>\n<li><a href=\"https://github.com/facebook/react/blob/16.3-dev/packages/shared/ReactSideEffectTags.js\">참고 - Side effect tags</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#%EC%99%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0%EB%A5%BC-%EB%B3%B4%EB%8A%94%EA%B0%80\">왜 <code class=\"language-text\">리액트 톺아보기</code>를 보는가</a></li>\n<li><a href=\"#1-render-phase\">1. Render phase</a></li>\n<li><a href=\"#2-commit-phase\">2. Commit phase</a></li>\n<li><a href=\"#3-vdomvirtual-dom\">3. VDOM(Virtual DOM)</a></li>\n<li><a href=\"#4-react-element\">4. React element</a></li>\n<li><a href=\"#5-fiber\">5. Fiber</a></li>\n<li><a href=\"#6-side-effect\">6. Side effect</a></li>\n<li><a href=\"#7-bit-masking\">7. Bit Masking</a></li>\n</ul>\n</div>","excerpt":"이 글은 스터디에서 리액트 톺아보기 2. Intro를 읽고 정리하며 주관적으로 정리한 글입니다. 글을 읽고 핵심적이거나 더 깊게 보고 싶은 부분을 정리하였습니다. 원문보다 더 가독성이 좋지 못할(?) 수 있으니 원문도 읽어보시는 것을 추천드립니다. 또한, 글을 읽고 이해한 내용을 바탕으로 작성한 글이기 때문에 틀린 내용이 있을 수 있습니다. 틀린 내용이 있다면 댓글로 알려주시면 감사하겠습니다. ⚛️ 리액트 톺아보기 왜 를 보는가 Next.js를 통해 한층 더 추상화된 React를 사용하다보니, 아이러니하게도 React에 대한 더 깊은 이해가 필요하겠다는 갈증이 들었다. 리액트 공식문서도 혼자서 1번, 스터디에서 1번 읽었지만 뭐랄까… 전반적인 React의 컨셉과 api 사용법은 알겠으나 그 내부 구현에 대한 건 생각보다 깊이 있게 들어가기가 힘들었다. 그러던 중  글을 발견하였고 한국말로 정리된 글 중 가장 깊이있는 글이라고 생각하여 해당 글을 읽기로 했다! 부디 지금 내가 느끼는 …","frontmatter":{"date":"October 14, 2023","title":"React 톺아보기를 톺아보기 - 2","categories":"스터디 아티클","author":"제이든","emoji":"⚛️"},"fields":{"slug":"/from-time-to-time/study/in-depth-react/2-intro/"}},"next":{"id":"d273d70e-e86f-565a-893f-9db22a6bb10a","html":"<p>이 글은 스터디에서 <a href=\"https://goidle.github.io/react/in-depth-react-preview/\">리액트 톺아보기 1. Preview</a>를 읽고 정리하며 주관적으로 정리한 글입니다. 글을 읽고 핵심적이거나 더 깊게 보고 싶은 부분을 정리하였습니다. 원문보다 더 가독성이 좋지 못할(?) 수 있으니 원문도 읽어보시는 것을 추천드립니다.</p>\n<p>또한, 글을 읽고 이해한 내용을 바탕으로 작성한 글이기 때문에 틀린 내용이 있을 수 있습니다. 틀린 내용이 있다면 댓글로 알려주시면 감사하겠습니다.</p>\n<h1 id=\"️-리액트-톺아보기\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"️ 리액트 톺아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>⚛️ 리액트 톺아보기</h1>\n<h2 id=\"왜-code-classlanguage-text리액트-톺아보기code를-보는가\" style=\"position:relative;\"><a href=\"#%EC%99%9C-code-classlanguage-text%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0code%EB%A5%BC-%EB%B3%B4%EB%8A%94%EA%B0%80\" aria-label=\"왜 code classlanguage text리액트 톺아보기code를 보는가 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>왜 <code class=\"language-text\">리액트 톺아보기</code>를 보는가</h2>\n<p>Next.js를 통해 한층 더 추상화된 React를 사용하다보니, 아이러니하게도 React에 대한 더 깊은 이해가 필요하겠다는 갈증이 들었다. 리액트 공식문서도 혼자서 1번, 스터디에서 1번 읽었지만 뭐랄까… 전반적인 React의 컨셉과 api 사용법은 알겠으나 그 내부 구현에 대한 건 생각보다 깊이 있게 들어가기가 힘들었다. 그러던 중 <code class=\"language-text\">리액트 톺아보기</code> 글을 발견하였고 한국말로 정리된 글 중 가장 깊이있는 글이라고 생각하여 해당 글을 읽기로 했다! 부디 지금 내가 느끼는 리액트에 대한 갈증이 해결되었으면 좋겠다.</p>\n<h2 id=\"1-글의-목적\" style=\"position:relative;\"><a href=\"#1-%EA%B8%80%EC%9D%98-%EB%AA%A9%EC%A0%81\" aria-label=\"1 글의 목적 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 글의 목적</h2>\n<p>리액트를 사용할 줄은 알지만, 아직도 리액트가 마법처럼 느껴지는 사람들을 위해 작성된 글이다.(나잖아..?) 그렇기에 리액트 응용, 에러 디버깅 등에 어려움을 겪을 수 있다.(난데..?)</p>\n<p>시리즈는 유저와의 인터렉션으로부터 훅을 통해 컴포넌트가 업데이트되고 DOM에 마운트되기까지의 과정을 실제 코드를 까보면서 진행될 예정이다.</p>\n<p>이 시리즈를 다 읽고나면 <code class=\"language-text\">Virtual DOM이 무엇인지, 컴포넌트 상태가 바뀌었을 때 리액트는 어떻게 해당 컴포넌트를 리렌더링시키는지, 어떻게 변경된 부분만 DOM에 마운트되는지, hook은 컴포넌트와 어떤 방식으로 매핑되어 사용되는지, 이벤트 구현은 어떻게 되어있는지 등</code>에 대한 큰 흐름을 이해할 수 있게 될 것이다. (🥳)</p>\n<blockquote>\n<p>저자는 글에 들어가기 앞서 리액트 패키지 폴더구조와 그 안에 무엇이 있는지 간단하게 살펴볼 것을 권장하고 있다.</p>\n</blockquote>\n<p>버전 16.3의 리액트 패키지 구조는 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67.22222222222223%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABeUlEQVQ4y4VT2W6EMAzk//+xUhdyEnIBC+GQprL3glbbfRjJSuyxx5NUX7WGCwkuZLQ+vQXlSNPiu5FolEEX873unFcJNyKlhBgTlmXBuq5vMQwjYoycn3Pm+Hq9Ytu2Z071rRO01jDGcCIdEvENr5jOnXNoGgEhJJTSHPuYT3nVxSSEELigPIn+gu59CNDacHNtDJM6nzDN5UzoXMdjL58IvefpiNRaC6kUqzrWVheTuVvf9we56y88CAOkVBBCQCgL6yLKPGM51FW1zdwxpfMu3knuvOepKD+QKdN02jubQp33ff8geWPJrXPsLqHrPPp+OEx4l0xLJinjOHLhX9kL1m1jgrquIaSCth26ruOafd+OknveIV2WUj6YEviJadPCtC/peZh+maINS/nkMu1PSHqDCkpJXOoGtnXoxwnzXFDKfYf0S7bnDtc3Lm9siiRC4+B85N+SCCnCh4zUT6gam1nKfw4/JqTG/AZbDx9u3++BlAf044wfkonlqJHcVt0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"리액트 패키지 폴더 구조\"\n        title=\"리액트 패키지 폴더 구조\"\n        src=\"/static/114a7c395baeee3fe53ad46181aa18c8/37523/1-react-structure.png\"\n        srcset=\"/static/114a7c395baeee3fe53ad46181aa18c8/e9ff0/1-react-structure.png 180w,\n/static/114a7c395baeee3fe53ad46181aa18c8/f21e7/1-react-structure.png 360w,\n/static/114a7c395baeee3fe53ad46181aa18c8/37523/1-react-structure.png 720w,\n/static/114a7c395baeee3fe53ad46181aa18c8/302a4/1-react-structure.png 1080w,\n/static/114a7c395baeee3fe53ad46181aa18c8/07a9c/1-react-structure.png 1440w,\n/static/114a7c395baeee3fe53ad46181aa18c8/37563/1-react-structure.png 2228w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>아래에도 나오겠지만, 일단 눈에 띄는 건 <code class=\"language-text\">react</code>, <code class=\"language-text\">react-dom</code>, <code class=\"language-text\">react-reconciler</code>, <code class=\"language-text\">scheduler</code>, <code class=\"language-text\">react-cache</code>, <code class=\"language-text\">events</code> 정도가 되지 않을까 싶다.</p>\n<p>각 폴더를 들어가보면 아래와 같은 내용이 나온다.</p>\n<p><code class=\"language-text\">react</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">React is a JavaScript library for creating user interfaces.\n리액트는 UI를 생성하기 위한 라이브러리임\n\nThe react package contains only the functionality necessary to define React components. It is typically used together with a React renderer like react-dom for the web, or react-native for the native environments.\n리액트 패키지는 오직 리액트 컴포넌트를 정의하기 위한 기능적 필요한 것들만 포함한다. 이건 보통 웹을 위한 react-dom이나 네이티브 환경을 위한 react-native와 함께 사용된다.\n\nNote: by default, React will be in development mode. The development version includes extra warnings about common mistakes, whereas the production version includes extra performance optimizations and strips all error messages. Don't forget to use the production build when deploying your application.</code></pre></div>\n<p><code class=\"language-text\">react-dom</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This package serves as the entry point to the DOM and server renderers for React. It is intended to be paired with the generic React package, which is shipped as react to npm.\n이 패키지는 리액트를 위한 DOM과 서버 렌더러의 진입점 역할을 한다. 이건 보통 npm에 react로 배포되는 일반적인 리액트 패키지와 함께 사용된다.</code></pre></div>\n<p><code class=\"language-text\">react-reconciler</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This is an experimental package for creating custom React renderers.\n이건 커스텀 리액트 렌더러를 만들기 위한 실험적인 패키지임\n\nIts API is not as stable as that of React, React Native, or React DOM, and does not follow the common versioning scheme.\n이 패키지의 API는 React, React Native, React DOM보다 안정적이지 않고, 일반적인 버전 관리 방식을 따르지 않는다.\n\n...? 일단 패스</code></pre></div>\n<p><code class=\"language-text\">scheduler</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">This is a package for cooperative scheduling in a browser environment. It is currently used internally by React, but we plan to make it more generic.\n이건 브라우저 환경에서 협력적인 스케줄링을 위한 패키지임. 현재는 리액트 내부에서만 사용되지만, 더 일반적인 용도로 사용할 계획이다.\n\nThe public API for this package is not yet finalized.\n이 패키지의 공개 API는 아직 최종화되지 않았다.\n\n흠... 스케쥴러도 아직 뭔지는 잘 모르겠다. 패스</code></pre></div>\n<p><code class=\"language-text\">react-cache</code></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">A basic cache for React applications. It also serves as a reference for more advanced caching implementations.\n리액트 애플리케이션을 위한 기본적인 캐시. 더 고급진 캐싱 구현을 위한 참고자료로도 사용된다.\n\nThis package is meant to be used alongside yet-to-be-released, experimental React features. It's unlikely to be useful in any other context.\n이 패키지는 아직 릴리즈되지 않은 실험적인 리액트 기능들과 함께 사용하기 위해 만들어졌다. 다른 컨텍스트에서는 유용하지 않을 것이다.\n\nDo not use in a real application. We're publishing this early for demonstration purposes.\n진짜 애플리케이션에서는 사용하지 마라. 우리는 이걸 데모 목적으로 일찍 배포하고 있다.\n\n여기도 아직은... (16버전이 나왔을 당시에는..!)</code></pre></div>\n<p>우선 위와 같은 역할들이 나누어져 있다는 것만 인지하고 시작해보자.</p>\n<h2 id=\"2-리액트-패키지-구조\" style=\"position:relative;\"><a href=\"#2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B5%AC%EC%A1%B0\" aria-label=\"2 리액트 패키지 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 리액트 패키지 구조</h2>\n<h3 id=\"react\" style=\"position:relative;\"><a href=\"#react\" aria-label=\"react permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react</h3>\n<ul>\n<li>컴포넌트 정의와 관련된 패키지</li>\n<li>React Element를 만드는 <code class=\"language-text\">createElement()</code>와 개발자에게 다른 패키지 모듈을 제공하는 중간 역할</li>\n<li>다른 패키지에 대한 의존가 없기 때문에 여러 플랫폼에서 사용 가능</li>\n</ul>\n<h3 id=\"renderer\" style=\"position:relative;\"><a href=\"#renderer\" aria-label=\"renderer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>renderer</h3>\n<ul>\n<li>react-dom, react-native-renderer 등 호스트의 렌더링 환경에 의존하는 패키지</li>\n<li>호스트와 react를 연결하는 역할</li>\n</ul>\n<h3 id=\"event\" style=\"position:relative;\"><a href=\"#event\" aria-label=\"event permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>event</h3>\n<ul>\n<li>SyntheticEvent(합성 이벤트)라는 명칭으로 내부적으로 개발된 이벤트 시스템</li>\n<li>개발자가 event를 제어하기 위해 기존 이벤트 시스템에 wrapping한 방식으로 이벤트 풀링, 이벤트 위임 등을 사용하여 구현됨</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Chat GPT\n\n리액트(React)에서 SyntheticEvent는 웹 애플리케이션 개발에서 이벤트 처리를 도와주는 중요한 개념 중 하나입니다. SyntheticEvent는 React에서 이벤트 처리를 추상화한 것으로, 웹 브라우저의 네이티브 이벤트를 래핑하여 제공합니다. 이를 통해 브라우저 간 호환성 문제를 해결하고, React 애플리케이션에서 이벤트 핸들링을 간단하게 만들어줍니다.\n\nSyntheticEvent의 주요 특징과 동작 방식을 자세히 설명하겠습니다:\n\n1. 브라우저 호환성 처리: SyntheticEvent는 브라우저 간 이벤트 핸들링의 차이를 추상화하므로, 다양한 브라우저에서 동일한 방식으로 이벤트를 처리할 수 있게 도와줍니다.\n\n2. 이벤트 풀링(Event Pooling): React는 이벤트 풀링을 통해 SyntheticEvent를 재사용합니다. 이것은 이벤트가 처리된 후에 해당 이벤트 객체를 재설정하고 다시 사용할 수 있게 합니다. 이로 인해 메모리 사용량을 줄이고 성능을 향상시킵니다.\n\n3. 이벤트 핸들러 작성: 컴포넌트에서 이벤트 핸들러를 작성할 때, SyntheticEvent를 사용하여 이벤트 정보에 접근할 수 있습니다. 예를 들어, 버튼 클릭 이벤트를 처리하는 핸들러 함수 내에서 `event.target`을 사용하여 이벤트가 발생한 DOM 요소에 접근할 수 있습니다.\n\n4. 이벤트 전파 방지: SyntheticEvent를 사용하여 이벤트 전파를 조절할 수 있습니다. 예를 들어, `event.stopPropagation()`을 호출하여 이벤트의 상위 요소로의 전파를 막을 수 있습니다.\n\n5. 동기 처리: SyntheticEvent는 비동기적으로 처리되지 않으며, 이벤트 핸들러가 실행 중일 때에만 유효합니다. 따라서 이벤트 핸들러 내에서 상태 업데이트 및 렌더링과 관련된 작업을 안전하게 수행할 수 있습니다.\n\n간단히 말해, SyntheticEvent는 React에서 이벤트 처리를 간편하게 만들어주고 브라우저 간 호환성 문제를 처리하는데 도움을 주는 중요한 도구입니다. 이를 통해 React 애플리케이션을 더 효율적으로 작성하고 유지보수할 수 있습니다.</code></pre></div>\n<h3 id=\"scheduler\" style=\"position:relative;\"><a href=\"#scheduler\" aria-label=\"scheduler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>scheduler</h3>\n<ul>\n<li>리액트는 여러가지 이유로 작업을 비동기로 진행함</li>\n<li>Task란 이름으로 우선순위에 따라 스케쥴링됨</li>\n<li>이 때, Task를 실행하기에 가장 적절한 시점을 결정하는 것이 스케쥴러</li>\n<li>즉, 리액트는 비동기 실행의 책임을 스케쥴러에게 위임하고 있다.</li>\n<li>호스트 환경에 의존적이다.</li>\n</ul>\n<h3 id=\"react-reconciler-리액트의-vdom과-관련된-패키지\" style=\"position:relative;\"><a href=\"#react-reconciler-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-vdom%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%ED%8C%A8%ED%82%A4%EC%A7%80\" aria-label=\"react reconciler 리액트의 vdom과 관련된 패키지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react-reconciler: 리액트의 VDOM과 관련된 패키지</h3>\n<ul>\n<li>리액트의 핵심 패키지</li>\n<li>v15 이전에는 <code class=\"language-text\">stack</code> 기반으로 구현</li>\n<li>v16 이후에는 <code class=\"language-text\">fiber architecture</code> 기반으로 구현</li>\n</ul>\n<h2 id=\"3-용어-정리\" style=\"position:relative;\"><a href=\"#3-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC\" aria-label=\"3 용어 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 용어 정리</h2>\n<h3 id=\"컴포넌트-구분\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B5%AC%EB%B6%84\" aria-label=\"컴포넌트 구분 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 구분</h3>\n<ul>\n<li>스태틱 컴포넌트: 리액트에서 자체 제공하는 컴포넌트</li>\n<li>호스트 컴포넌트: 플랫폼에서 제공하는 컴포넌트</li>\n<li>커스텀 컴포넌트: 개발자가 직접 만든 컴포넌트</li>\n</ul>\n<h3 id=\"렌더링\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81\" aria-label=\"렌더링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더링?</h3>\n<ul>\n<li>일반적으로 <code class=\"language-text\">컴포넌트 렌더링 === 컴포넌트 호출</code></li>\n<li>하지만 세부적으로 가면 여러 단계가 더 존재하기 때문에 세분화가 필요하다.</li>\n<li>컴포넌트의 호출은 <code class=\"language-text\">reconciler</code>에서 한다. 그 다음 VDOM 재조정 과정이 진행되고 이후에 <code class=\"language-text\">renderer</code>에서 마운트를 한다. 즉, <code class=\"language-text\">컴포넌트의 호출 !== DOM 삽입</code>이다. 심지어 리액트에서는 DOM 삽입과 화면에 그려지는 것 또한 별개로 다룬다. 🤔</li>\n</ul>\n<p>정리해보자면</p>\n<ul>\n<li><code class=\"language-text\">렌더링</code>: 컴포넌트가 호출되어 자식을 반환하고 VDOM에 적용하는 과정 => reconciler가 하는 일</li>\n<li><code class=\"language-text\">마운트</code>: VDOM을 실제 DOM에 적용하는 과정 => renderer가 하는 일</li>\n<li><code class=\"language-text\">페인트</code>: 브라우저가 마운트된 DOM을 화면에 그리는 과정</li>\n</ul>\n<p>흠… 흔히 우리가 리액트에서 <code class=\"language-text\">렌더링이 일어난다</code>고 표현하는 것도 개발자마다 조금씩 다른 느낌으로 쓰는 것 같다. 위의 정의대로 일단 기억하도록 하자!!</p>\n<blockquote>\n<p><code class=\"language-text\">컴포넌트 호출</code>: 그저 React Element를 반환하는 함수를 호출하는 것! 그 이상도, 그 이하도 아니다.</p>\n</blockquote>\n<h3 id=\"virtual-domvdom-가상돔\" style=\"position:relative;\"><a href=\"#virtual-domvdom-%EA%B0%80%EC%83%81%EB%8F%94\" aria-label=\"virtual domvdom 가상돔 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual DOM(VDOM; 가상돔)</h3>\n<ol>\n<li>\n<p>reactElement, fiber</p>\n<ul>\n<li>reactElement: 컴포넌트의 정보를 담은 모델 <code class=\"language-text\">객체</code>, 컴포넌트가 반환하는 것은 JSX가 아니라 reactElement(객체)이다.</li>\n<li>fiber: VDOM의 노드 객체, reactElement를 VDOM에 올리기 위해 확장한 객체이다. fiber를 통해 컴포넌트의 상태, 훅, 라이프 사이클 등 대부분의 것들이 관리된다.\n<ul>\n<li>(GPT) 컴포넌트의 정보를 담은 모델 <code class=\"language-text\">트리</code>, 컴포넌트의 정보를 담은 reactElement를 트리 구조로 관리하는 것이 fiber이다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>current, workInProgress</p>\n</li>\n</ol>\n<ul>\n<li>리액트는 더블 버퍼링 형태로 VDOM을 설계하였다.</li>\n<li>current: 마운트가 끝난 트리 => 현재 VDOM</li>\n<li>workInProgress: 업데이트가 적용중인 트리 => 변경된(변경 중인) VDOM</li>\n</ul>\n<blockquote>\n<p>버퍼란 <code class=\"language-text\">어떤 장치에서 다른 장치로 데이터를 송신할 때 일어나는 시간의 차이나 데이터 흐름의 속도 차이를 조정하기 위해 일시적으로 데이터를 기억시키는 장치</code>이다.(<a href=\"https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%EB%B2%84%ED%8D%BC%EB%A7%81\">위키백과</a>)<br/>\n더블 버퍼링이란 <code class=\"language-text\">데이터를 기억시키는 장치를 2개 사용하여 데이터를 송신하는 장치와 수신하는 장치의 속도 차이를 조정하는 방식</code>이다.<br/>\n즉, 리액트의 VDOM은 현재의 VDOM과 변경 중인 VDOM을 따로 관리하여 변경 중인 VDOM이 완성되면 현재의 VDOM과 교체하는 방식으로 동작한다.</p>\n</blockquote>\n<h1 id=\"출처\" style=\"position:relative;\"><a href=\"#%EC%B6%9C%EC%B2%98\" aria-label=\"출처 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>출처</h1>\n<ul>\n<li><a href=\"https://goidle.github.io/react/in-depth-react-preview/\">리액트 톺아보기 1. Preview</a></li>\n<li><a href=\"https://github.com/facebook/react/tree/16.3-dev/packages\">React v16.3.0 packages</a></li>\n<li><a href=\"https://ko.wikipedia.org/wiki/%EB%8B%A4%EC%A4%91_%EB%B2%84%ED%8D%BC%EB%A7%81\">위키백과: 버퍼</a></li>\n<li><a href=\"https://coding-factory.tistory.com/692\">더블 버퍼링이란</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EC%99%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%86%BA%EC%95%84%EB%B3%B4%EA%B8%B0%EB%A5%BC-%EB%B3%B4%EB%8A%94%EA%B0%80\">왜 <code class=\"language-text\">리액트 톺아보기</code>를 보는가</a></p>\n</li>\n<li>\n<p><a href=\"#1-%EA%B8%80%EC%9D%98-%EB%AA%A9%EC%A0%81\">1. 글의 목적</a></p>\n</li>\n<li>\n<p><a href=\"#2-%EB%A6%AC%EC%95%A1%ED%8A%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B5%AC%EC%A1%B0\">2. 리액트 패키지 구조</a></p>\n<ul>\n<li><a href=\"#react\">react</a></li>\n<li><a href=\"#renderer\">renderer</a></li>\n<li><a href=\"#event\">event</a></li>\n<li><a href=\"#scheduler\">scheduler</a></li>\n<li><a href=\"#react-reconciler-%EB%A6%AC%EC%95%A1%ED%8A%B8%EC%9D%98-vdom%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%ED%8C%A8%ED%82%A4%EC%A7%80\">react-reconciler: 리액트의 VDOM과 관련된 패키지</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%EC%9A%A9%EC%96%B4-%EC%A0%95%EB%A6%AC\">3. 용어 정리</a></p>\n<ul>\n<li><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B5%AC%EB%B6%84\">컴포넌트 구분</a></li>\n<li><a href=\"#%EB%A0%8C%EB%8D%94%EB%A7%81\">렌더링?</a></li>\n<li><a href=\"#virtual-domvdom-%EA%B0%80%EC%83%81%EB%8F%94\">Virtual DOM(VDOM; 가상돔)</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 14, 2023","title":"React 톺아보기를 톺아보기 - 1","categories":"스터디 아티클","author":"제이든","emoji":"⚛️"},"fields":{"slug":"/from-time-to-time/study/in-depth-react/1-preview/"}},"prev":{"id":"58e21915-3ee9-58dc-9e68-990ce3896192","html":"<h1 id=\"-성장일지-70\" style=\"position:relative;\"><a href=\"#-%EC%84%B1%EC%9E%A5%EC%9D%BC%EC%A7%80-70\" aria-label=\" 성장일지 70 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🚤 성장일지 7.0</h1>\n<p>책 <code class=\"language-text\">행복한 이기주의자(웨인 다이어)</code>의 내용에 자극받아 시작하는 소박한 <code class=\"language-text\">성장기록</code></p>\n<blockquote>\n<p>살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>\n성장하고 있는 것이 살아 있는 것이다.<br/>\n생명의 유일한 증거는 성장이다!</p>\n</blockquote>\n<blockquote>\n<p>⚛ (7.0)&#x3C;완전 개편> <code class=\"language-text\">파인만 학습법</code>을 알게 된만큼, 성장일지는 정말 그 날의 키워드 중심으로 간단하게 정리하도록 한다.</p>\n</blockquote>\n<h2 id=\"usereducer\" style=\"position:relative;\"><a href=\"#usereducer\" aria-label=\"usereducer permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useReducer</h2>\n<p>사실 그동안 <code class=\"language-text\">useReducer</code>에 대해서 <code class=\"language-text\">굳이..?</code>라는 생각을 자주 했었다. 내가 다루는 프로젝트 수준에서의 상태가 그렇게 복잡하지도 않았고, 애초에 그렇게 복잡하게 관리되는 상태라면 여러개의 state로 분리하는 게 개인적으로는 개발자 경험에도 좋다고 생각했기 때문이다. 또 그러다가 상태를 핸들링하는 함수가 다소 복잡하거나 지저분하면 그 부분만 커스텀 훅으로 분리하기만 해도 충분하다고 생각했기 때문이다. 그러다 오늘 강의를 듣고 테스트 코드를 작성하면서 <code class=\"language-text\">useReducer</code>의 필요성을 느꼈다. 앞에서 말했던 것처럼 사실 잘 분리하고 조작만 한다면 <code class=\"language-text\">useState</code>로도 충분히 깔끔한 코드를 짤 수 있다고 생각한다. 다만, state를 다루는 로직을 <code class=\"language-text\">reducer</code>라는 순수함수로 분리함으로써 개발자 경험뿐 아니라 state의 응집도를 높일 수 있었고 무엇보다 테스트 코드를 작성하기 수월해졌다. 앞으로도 가능하면 <code class=\"language-text\">useReducer</code>를 사용하도록 (억지로라도) 해보려 한다!!!</p>\n<h2 id=\"ajax\" style=\"position:relative;\"><a href=\"#ajax\" aria-label=\"ajax permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ajax</h2>\n<p>오늘 CS - 네트워크 스터디를 준비하면서 <code class=\"language-text\">Ajax가 무엇인지 설명해주세요.</code>라는 질문이 있었다. 정말 단순하게 <code class=\"language-text\">Ajax는 비동기적으로 서버와 통신하는 무언가 새로 등장한 기술</code>이라고 생각했다. 그렇지만 좀더 찾아보고 공부해서 준비한 내 대답은 아래와 같았다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Ajax란 비동기적인 자바스크립트와 XML이라는 의미로 새로운 언어나 개념이라기보단 비동기적으로 데이터만 받아와서 화면을 업데이트할 수 있는 개발 기법입니다.\n일반적으로 웹 페이지의 뼈대를 그리는 html, 스타일을 담당하는 css, 그리고 동작을 담당하는 JavaScript를 기본으로 JS에서 특정 data만 요청하는 로직을 함께 쓰는 경우가 대부분입니다.\nAjax 기법이 등장하기 이전에는 각 페이지마다 서버에서 완성된 html을 만들어서 보내줘야했습니다. 유저의 정보나 페이지 번호 등에 따라 페이지의 일부가 변하는 상황에서도 그대로 유지되는\nhtml까지 다시 전부 그려야했습니다. Ajax를 통해 처음 페이지 요청에서만 html, css, js 를 받고 유저의 인터렉션에 따라 data를 요청하여 화면의 일부분만 변경함으로써 기존과는 완전히 다른\n사용자 경험을 제공할 수 있게 되었습니다.</code></pre></div>\n<p>비슷할 수도 있지만 내가 느꼈던 어떤 본질적인 느낌이랑은 다른 것 같다. 솔직히 ajax하면 당장 떠오르는 게 xmlHttpRequest 혹은 fetch api이었는데 이런 여러가지를 조합해서 개발하는 기법이라는 게 신기했다.(지금은 이 세트가 너무 당연한데…)</p>\n<p>아 그리고 <code class=\"language-text\">Asynchronous JavaScript and XML</code>에서 xml은 정말 단순하게 말하자면 html 같은 녀석인데, 화면의 골격을 잡으려는 목적이 강한 html과는 다르게 데이터를 표한하기 위한 목적이 강한 마크업 언어이다.(더 단순하게 말하면 지금 우리가 데이터를 전달할 때 사용하는 형태인 JSON의 마크업 버전이라고 생각하면 된다.) 그 당시에는 xml을 사용하는 것이 일반적이었어서 ajax가 되었다.</p>\n<h1 id=\"-회고\" style=\"position:relative;\"><a href=\"#-%ED%9A%8C%EA%B3%A0\" aria-label=\" 회고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📝 회고</h1>\n<p>시간이 빠르더라도 그 속에서 그 흐름을 잘 인지하면서 살도록 하자! 그래야 더 알차고 의미있는 삶을 살 수 있다.</p>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/Ajax\">위키백과: Ajax</a></li>\n<li><a href=\"https://www.tcpschool.com/ajax/intro\">TCP 스쿨: Ajax 개요</a></li>\n</ul>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#usereducer\">useReducer</a></li>\n<li><a href=\"#ajax\">Ajax</a></li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</div>","frontmatter":{"date":"October 16, 2023","title":"231016(월) 성장","categories":"성장일지","author":"제이든","emoji":"🌱"},"fields":{"slug":"/steadily/growth-diary/2023/10/16/"}},"site":{"siteMetadata":{"siteUrl":"https://JaydenLee1116.github.io","comments":{"utterances":{"repo":"JaydenLee1116/JaydenLee1116.github.io"}}}}},"pageContext":{"slug":"/from-time-to-time/study/in-depth-react/2-intro/","nextSlug":"/from-time-to-time/study/in-depth-react/1-preview/","prevSlug":"/steadily/growth-diary/2023/10/16/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}