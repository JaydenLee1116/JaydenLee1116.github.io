---
emoji: 🌱
title: 230105(목)
date: '2023-01-05 23:00:00'
author: 제이든
tags: 기록 일지 성장 발전 개발
categories: 성장일지
---

## 🎄 성장일지 3.1

책 `행복한 이기주의자(웨인 다이어)`의 내용에 자극받아 시작하는 소박한 `성장기록`

> 살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>
> 성장하고 있는 것이 살아 있는 것이다.<br/>
> 생명의 유일한 증거는 성장이다!

> 🌳 키워드 (1.0)<br/>
> 최대한 간단하게 정리, 추후에 보면서 스스로 설명<br/>
> 🍉 경험 위주로 (2.0)<br/>
> 단순 정보를 전달하기보다 무엇을 배웠고 어떻게 해결했는지 짧고 간단하게 작성<br/>
> ❄️ 정해진 템플릿에 맞춰서 (3.0)<br/>
> 키워드, 경험 모두 좋다. 다만 매일 작성하기로 마음 먹은만큼 핵심만 간결하게 정리할 수 있게 템플릿을 작성
> (3.1) 230102부터 시작되는 학습에 관한 내용 추가

### 🔑 오늘의 키워드

#### Storage, Memory, CPU

- Storage: 디스켓, CD, HDD, SDD와 같은 저장소. 용량이 크고 비교적 가격이 싸다. 자료를 `저장`하는 용도. 컴퓨터를 꺼도 남아있다.
- Memory: 흔히 RAM이라고 부르는 메모리. 용량이 작고 컴퓨터를 종료하면 데이터가 사라진다. 데이터를 빠르게 `운반`할 수 있다.(가져올 수 있다.)
- CPU: 중앙처리장치. 데이터를 처리하는 속도가 가장 빠르다.

> 그렇기 때문에 Storage -> Memory -> CPU 순서로 데이터를 운반하게 된다.(저장소 -> 빠른 운반책 -> 빠른 처리소)
> 자료 구조의 가장 중요한 미션은 Memory 사용을 줄이는 것이다.

- 각각의 주소(데이터가 저장되어있는)에 접근하는 걸리는 시간이 동일한 메모리를 `RAM(Random Access Memory)`라고 한다.
  - 즉, 주소만 안다면 원하는 데이터를 빠르게 가져올 수 있다.

#### Array, Array List, Linked List

- Array(배열)
  - index를 통해 value에 접근한다.
  - 배열 가운데의 원소가 삭제되면 null값이 된다.
  - index를 통한 탐색 시, O(1)
- Array List(연속 배열, 연속 리스트)
  - 각각의 데이터가 연속된 메모리 주소에 나열되어 저장된다.
  - index를 통해 value에 접근한다.
  - 배열 가운데의 원소가 삭제되면 뒤의 원소가 한 칸 당겨진다. -> 삽입/삭제 시 각 원소가 이동하므로 효율적이지 못하다.
  - 탐색은 용이하지만, 삽입/삭제의 효율은 떨어진다.(탐색: O(1), 삽입/삭제: O(n))
- Linked List(연결 리스트)
  - 각각의 데이터가 메모리 곳곳에 흩어져 있되, 각 데이터가 다음 데이터에 대한 정보를 담고 있어 연결되어있다.
  - 포인터 부분(다음 데이터를 가리키는, 참조하는 부분)이 필요하기 때문에 공간 효율은 좋지 못하다.
  - 탐색은 처음부터 하나하나 포인터를 통해 가기 때문에 효율적이지 못하지만, 삽입/삭제 시 포인터만 연결 혹은 제거하면 되기 때문에 효율적이다.(탐색: O(n), 삽입/삭제: O(1))

#### 자바스크립트에서 변수의 메모리 주소를 확인할 수 있는가?

- 결론: `알 수 없다.`

자바스크립트 언어는 C++로 만들어진 V8엔진을 통해 파싱되어 코드가 해석된다.(chrome, nodejs 모두) 이 때, 중간에 V8엔진이 개입하기 때문에 C++처럼 메모리 주소를 얻을 수 없다.

> 참고로 C++에서 보여지는 메모리 주소도 실제 물리적인 메모리 주소가 아니다. 각 운영체제에서 할당한 가상 메모리 주소이다.
> 추가: 크롬 개발자 도구에서 Memory를 통해 확인 가능한 주소가 있기는 한데, 이게 실제 물리적인 메모리인지는 확실치 않다.(아마도 아닌 것 같다.)

#### UUID(Universal Unique IDentifier, 범용 고유 식별자)

- UUID: 어떤 개체(데이터)를 고유하게 식별하는 데 사용되는 표준
- 주로 네트워크 상 서로 모르는 개체들을 식별하기 위해 사용된다.
- 아주 엄밀히 따지면 완벽하게 고유성을 갖지는 않지만, 사실상 중복될 가능성이 거의 없다고 인정되기 때문에 많이 사용된다.

> 자바스크립트의 Math.random()은 암호학적으로 안전한 난수를 생성하는 것이 아니다. 그러므로 보안이 중요한 로직에서는 사용하지 않는 게 좋다.

Web Crypto API

- 브라우저에서 사용방법

```js
let arr = new Uint32Array(10);
window.crypto.getRandomValues(arr);
// arr가 어떻게 변했는지 확인해보자
```

- Nodejs에서 사용방법

```js
const getUuid = () => {
  const randomBytes = require('crypto').randomBytes(2);
  const randomNumber = randomBytes.toString('hex');
  return randomNumber;
};
```

##### 참고 자료

- [자바스크립트 배열은 배열이 아니다.](https://poiemaweb.com/js-array-is-not-arrray)
- [UUID와 자바스크립트 난수 생성기 feat. crypto API](https://yjh5369.tistory.com/entry/javascript-random-number-generation)

### 📝 요약 및 하루 간단 회고

자바스크립트의 배열에 대해서 좀더 깊게 알 수 있는 하루였다. 또, 매번 Memory에 대한 개념을 막연하게만 기억하고 있었는데 오늘을 계기로 좀 확실히 알 것 같다. 공부할 때마다 느끼지만, 공부할수록 컴퓨터가
어떻게 발전해왔는지 느껴지는 게 재미있다. 당시 사람들이 필요에 의해서 다양한 자료 구조들을 구현하고 알고리즘을 생각해내고 나아가 하드웨어 구성을 한 게 참 신기하다. 그 당시에 프로그래밍을 공부했다면, 정말
`새로운 시도`가 될만한 것들이 많을 것 같다. 아마 미래에는 지금도 정말 정말 다양한 기술들이 없었던 시기로 느껴지지 않을까 싶다. 계속 더 공부하고 배움에 재미를 느끼는 개발자가 되자!

```toc

```
