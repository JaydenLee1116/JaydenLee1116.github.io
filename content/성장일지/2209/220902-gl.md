---
emoji: 🌱
title: 220902(금)
date: '2022-09-01 18:30:00'
author: 제이든
tags: 기록 일지 성장 발전 개발
categories: 성장일지 JAVASCRIPT 네트워크
---

## 🪴 성장일지

책 `행복한 이기주의자(웨인 다이어)`의 내용에 자극받아 시작하는 소박한 `성장기록`

> 살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>
> 성장하고 있는 것이 살아 있는 것이다.<br/>
> 생명의 유일한 증거는 성장이다!

> 🌳 키워드
> 최대한 간단하게 정리, 추후에 보면서 스스로 설명

### `네트워크` 물리 계층(OSI의 1계층)

물리 계층

- 0과 1만으로 이루어진 비트열을 전기 신호로 변환하기 위해 존재하는 계층
- 컴퓨터와 네트워크 장비를 연결 및 서로 간에 전송되는 데이터를 전기 신호로 변환하는 계층

#### 전기 신호 종류

- 아날로그 신호: 파형(물결 모양)으로 주로 전화 회선, 라디오 방송 등에서 사용되는 신호
- 디지털 신호: 막대 모양으로 컴퓨터의 0과 1 비트열을 전달하기 위해 사용되는 전기 신호

#### 랜 카드

네트워크를 통해 데이터를 송수신할 수 있도록 메인 보드 내에 있는 랜 카드 혹은 별도의 랜 카드를 사용

#### 네트워크 전송 매체

전송 매체란 `데이터가 흐르는 물리적인 선로`로 크게 유선과 무선으로 구분

##### 트위스트 페어 케이블(유선)

일반적으로 흔히 `랜 케이블, 랜 선`이라 부르는 케이블
케이블의 양쪽 끝에는 `RJ-45`라는 커넥터가 붙어있다.(랜 꽂으면 딸깍 소리나는 부분)

케이블의 종류

- UTP(Unshielded Twist Pair)

  - 구리 선 8개를 2개씩 꼬아 만든 네 쌍의 전선으로 따로 실드 보호가 되어있지 않아 노이즈의 영향을 받기 쉬움
  - 저렴하기 때문에 일반적으로 많이 사용

- STP(Shielded Twist Pair)
  - 2개씩 꼬아 만든 선을 실드로 보호한 케이블
  - 실드가 있어 노이즈가 적으나 가격이 비싸 보편적으로 사용하지는 않음

통신 규격에 따른 분류

- 다이렉트 케이블

  - 8개의 구리 선을 같은 순서로 커넥터에 연결한 케이블
  - 주로 컴퓨터와 스위치를 연결할 때 사용

- 크로스 케이블
  - 8개의 구리 선 중 한쪽 커넥터의 1, 2번 연결을 다른 쪽 커넥터의 3, 6번에 연결한 케이블
  - 컴퓨터끼리 직접 연결할 때(컴퓨터 간 직접 데이터를 보낼 때는, 양쪽 모두 1,2번을 사용하기에 이렇게 크로스한 것)

#### 리피터와 허브

##### 리피터

일그러진 전기 신호를 복원(정형)하고 증폭하는 기능을 가진 네트워크 중계 장비<br/>
즉, 케이블이 너무 길어지면 일어나는 전기 신호의 손실을 중간에서 복원(고속도로 휴게소처럼)</br>
요즘엔 다른 네트워크 장비에서 리피터 기능을 지원하기에 장비로서 리피터는 거의 쓰지 않는다.

##### 허브

리피터와 마찬가지로 전기 신호를 복원하고 증폭하는 기능<br/>
실제로 통신하는 통로인 포트를 여러개 가지고 있어 리피터 허브라고도 부른다.<br/>
리피터와 다르게 포트를 여러 개 가지고 있어 컴퓨터 여러대와 통신 가능

> 컴퓨터1, 2, 3, 4, 5가 허브에 연결되어있고 1에서 2로 데이터를 송신할 때, 허브에 연결된 나머지 컴퓨터(3, 4, 5)에도 데이터가 전송된다.
> 3~5에게는 불필요한 데이터이기에 허브를 더미 허브라고 부르기도 하고 이를 해결하기 위해 존재하는 것이 `스위치`

### `JavaScript` 프로퍼티 어트리뷰트

자바스크립트 엔진은 프로퍼티를 생성할 때 `프로퍼티의 상태`를 나타내는 `프로퍼티 어트리뷰트`를 기본적으로 자동 정의한다.

- 프로퍼티의 값(value)
- 값의 갱신 가능 여부(writable)
- 열거 가능 여부(enumerable)
- 재정의 가능 여부(configurable)

프로퍼티 어트리뷰트에는 직접 접근할 수는 없지만, Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인 가능하다.

#### 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티(우리가 흔히 생각하는 키와 벨류)
- 접근자 프로퍼티: 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
  - get, set 같은 녀석들(ㅂㄷㅂㄷ)

#### 객체 변경 방지

- 객체 확장 금지: Object.preventExtensions
- 객체 밀봉: Object.seal
- `객체 동결`: Object.freeze, 오로지 읽기만 가능 -> 얘만 기억해도 될듯

> 다만, 객체 동결도 중첩 객체는 완전히 동결시키지 못한다.(얕은 복사와 깊은 복사처럼 얕은 동결임)
> 재귀를 통한 `깊은 동결` 구현(깊은 복사처럼 무조건 알고 있어야하는 건 아니지만 기억해두자!)

```js
function deepFreeze(target) {
  if (target && typeof target === 'object' && !Object.isFrozen(target)) {
    Object.freeze(target);
    Object.keys(target).forEach((key) => deepFreeze(target[key]));
  }
  return target;
}
```

### `JavaScript` 생성자 함수

객체를 생성하는 방법 중 하나인 `생성자 함수`

- 함수는 new 연산자와 함께 호출되면 생성자 함수로 동작하며 암묵적으로 인스턴스르 반환한다.
- 일반 객체는 호출할 수 없지만, 함수는 호출할 수 있다.

#### constructor

- constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수라는 점)
- non-constructor: 메서드(ES6에서의 메서드 축약 표현), 화살표 함수

#### new.target과 스코프 세이프 생성자 패턴

new.target은 함수 자신(생성자 함수)를 가리킨다.

```js
// new.target을 이용해 new 연산자를 안썼을 때에 대한 방지
function Dog(name, age) {
  if (!new.target) {
    return new Dog(name, age);
  }

  this.name = name;
  this.age = age;
}
```

```js
// new.target을 사용하지못할 때(ES6 이전)
// 스코프 세이프 생성자 패턴 이용
// new 키워드를 안쓰면 this가 전역 객체에 바인딩되므로

function Dog(name, age) {
  if (!(this instanceof Dog)) {
    return new Dog(name, age);
  }

  this.name = name;
  this.age = age;
}
```

#### 빌트인 생성자 함수

Object, Function 생성자 함수는 new 연산자가 없이 호출해도 new 연산자를 붙인 것처럼 동작한다.<br/>
반면 String, Number, Boolean 생성자 함수는 new 연산자 없이 호출하면 각각 문자열, 숫자, 불리언 값을 반환한다.(우리가 데이터 타입을 변경할 때, String, Number, Boolean을 사용할 수 있는 이유)

```toc

```
