---
emoji: 🌱
title: 230909(토)
date: '2023-09-09 23:30:00'
author: 제이든
tags: 기록 일지 성장 발전 개발
categories: 성장일지
---

## 🚤 성장일지 7.0

책 `행복한 이기주의자(웨인 다이어)`의 내용에 자극받아 시작하는 소박한 `성장기록`

> 살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>
> 성장하고 있는 것이 살아 있는 것이다.<br/>
> 생명의 유일한 증거는 성장이다!

> ⚛ (7.0)<완전 개편> `파인만 학습법`을 알게 된만큼, 성장일지는 정말 그 날의 키워드 중심으로 간단하게 정리하도록 한다.

## ⚛️ 키워드: 직관적이고 쉽고 간단하게 작성

### Next.js

- Next.js는 다양한 라이브러리를 조합하는 React를 사용하는 개발자들을 위한 프레임워크이다.
- 아래와 같은 것들을 지원한다.
  - 풀스택 기반
  - File-based routing(파일 기반 라우팅)
  - 최적화 ex) SEO, Image, Font
  - SSR 뿐 아니라 다양한 형태를 결합한 하이브리드 렌더링 제공

1. 리액트로 구현한 어플리케이션은 기본적으로 CSR 방식으로 렌더링을 한다. 그러다보니 초기 로딩속도, SEO, 보안 등의 단점이 존재한다.
2. 이를 보완하기 위해 SSG 방식이 등장했다. SSG 방식은 빌드 시점에 미리 페이지를 렌더링하여 정적인 페이지를 생성한다. 이렇게 생성된 정적인 페이지는 CDN에 캐싱할 수 있어 빠른 로딩 속도를 보장한다. 하지만, 정적인 페이지이기 때문에 동적인 데이터를 사용할 수 없다는 단점이 존재한다.
3. 이를 보완하기 위해 ISR 방식이 등장했다. 처음 빌드 시점에 미리 html 파일을 만들어서 응답하던 SSG와는 다르게 일정 시간마다 정적인 페이지를 재생성한다. 이렇게 재생성된 정적인 페이지는 CDN에 캐싱할 수 있어 빠른 로딩 속도를 보장한다. 또한, 그나마 데이터를 동적으로 사용할 수 있어 SSG의 단점을 보완한다. 그럼에도 여전히 실시간 데이터가 반영되는 게 아니라는 단점이 존재한다.
4. 이를 보완하기 위해 SSR 방식이 등장했다. CSR과 비슷하지만, 유저의 요청이 있을 때마다 서버에서 html을 생성하여 응답한다. 이렇게 생성된 html은 CDN에 캐싱할 수 있어 빠른 로딩 속도를 보장한다. 또한, 실시간 데이터를 사용할 수 있어 SSG, ISR의 단점을 보완한다. 하지만, 서버에서 html을 생성하기 때문에 서버의 부하가 증가한다는 단점이 존재한다.
5. 따라서 어플리케이션에서 페이지의 특성 혹은 페이지의 일부분의 특성에 따라 CSR, SSG, ISR, SSR을 적절히 사용해야 한다. 이를 위해 Next.js는 각 페이지의 특성에 따라 CSR, SSG, ISR, SSR을 적절히 사용할 수 있도록 지원한다.

### 이진 탐색

- 숫자가 정렬된 배열에서 특정 숫자를 찾는 알고리즘
- 일반적인 탐색 알고리즘은 순차적으로 탐색하므로 O(n)의 시간 복잡도를 가지지만, 이진 탐색은 O(log n)의 시간 복잡도를 가진다.
- 이진 탐색은 배열의 중간 인덱스를 찾아서, 찾고자 하는 숫자와 비교하고, 중간 인덱스의 숫자가 찾고자 하는 숫자보다 크면 왼쪽을, 작으면 오른쪽을 탐색한다.
- 이진 탐색은 배열이 정렬되어 있어야만 사용할 수 있다.
- 이진 탐색은 반복문, 재귀함수로 구현할 수 있다.

구현 예시

```js
// 반복문
function binarySearch(array, target) {
  let left = 0;
  let right = array.length - 1;

  while (left <= right) {
    let mid = Math.floor((left + right) / 2);

    if (array[mid] === target) {
      return mid;
    } else if (array[mid] < target) {
      left = mid + 1;
    } else if (array[mid] > target) {
      right = mid - 1;
    }
  }

  return -1;
}

// 재귀함수

function binarySearch(array, target, left, right) {
  if (left > right) {
    return -1;
  }

  let mid = Math.floor((left + right) / 2);

  if (array[mid] === target) {
    return mid;
  } else if (array[mid] < target) {
    return binarySearch(array, target, mid + 1, right);
  } else if (array[mid] > target) {
    return binarySearch(array, target, left, mid - 1);
  }
}
```

## 📝 회고

드디어 Next.js 강의를 듣기 시작했다. 사실 그동안 `Next.js까지 신입이 알 필요가 있을까?`라는 마음에 기본 JS와 React 공부에 더 힘을 썼다. 그러다 오늘 동기인 나니와 대화 중 `가고 싶은 회사의 기술 스택으로 있어서 빨리 배우려 했다`는 대답을 들었다. 해서 내가 가고싶은 기업들의 기술스택을 다시 한 번 찾아봤고, 많은 기업들이 Next.js 를 사용하고 있다는 걸 알게 되었다. 또, 지금 현재는 SSG 형태의 Gatsby로 구현된 블로그를 사용하고 있는데, 조금 엉성하더라도 직접 구현해보는 게 좋을 것 같다는 생각에 추후에 Next.js를 사용해서 블로그를 구현해볼 예정이다.

## 참고

```toc

```
