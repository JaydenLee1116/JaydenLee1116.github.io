---
emoji: 🌱
title: 230727(목)
date: '2023-07-27 22:30:00'
author: 제이든
tags: 기록 일지 성장 발전 개발
categories: 성장일지
---

## 🚤 성장일지 6.0

책 `행복한 이기주의자(웨인 다이어)`의 내용에 자극받아 시작하는 소박한 `성장기록`

> 살아있는 꽃과 죽은 꽃은 어떻게 구별하는가?<br/>
> 성장하고 있는 것이 살아 있는 것이다.<br/>
> 생명의 유일한 증거는 성장이다!

> 🌾 (4.0)학습 키워드에서 최대한 간단한 정보 제공, 고민에서 내 경험을 자세히 적자!<br/>
> 🥊 (5.0)학습 키워드는 한줄의 핵심으로만 정리, 성공/실패 일지 작성하기! 이 때, 실패의 경험은 자세히 적기!<br/>
> 🍉 (6.0)<완전 개편!!!> 매일 습관적으로 핵심만 적을 수 있게 프레임 변경. 성공보단 실패에 초점을 맞추기.<br/>
>
> - 🍉 (6.1)<수정> 매번 성공, 실패를 따로 적는 것보단 경험으로 표현하자

## 🌈 오늘의 감정

새로운데 아직 적응이 되질 않는 느낌..?! 오늘은 처음으로 아웃풋 기반의 계획을 작성해보았다. 아직 아웃풋을 중심으로 계획을 세우는 게 쉽진 않지만, 그래도 뭔가 좀더 가시적인 결과에 초점을 맞추니까
스트레스도 덜한 것 같고 뭔가 더 명확한 하루가 되는 것 같다. 물론 아직 서툴러서, 아주 효율적이라는 느낌까지는 아니지만 ㅎㅎ

## 🫧 오늘의 고민

### 클로저를 사용하는 것은 함수형 패러다임에 어긋나는가?

오늘은 함수형 프로그래밍을 공부하면서 명시적 입력, 출력 그리고 암묵적 입력, 출력을 구분하는 법을 배웠다. 여기서 명시적 입력은 함수의 인자, 명시적 출력은 함수의 반환값을 의미한다. 그리고 이를 제외한
모든 입력과 출력은 암묵적인 값으로 우리가 흔히 아는 `side effect(부수 효과)`가 된다. 헌데 내가 느낀 객체지향과 함수형의 가장 비슷하면서도 묘하게 다른 포인트는 바로 클로저를 사용하는 것이다.
객체지향은 주로 class로 구현을 하다보니 그 객체 자체가 프로퍼티(상태)와 메서드를 갖는다. 함수는 내부적으로 선언한 변수(상태)를 사용할 수는 있지만, 그 변수를 외부에서 접근할 수는 없다. 그래서
함수형 프로그래밍에서는 클로저를 사용해서 외부에서 접근할 수 없는 변수를 만들어서 상태를 관리한다. 그렇다면 이건 부수 효과가 아닌가..? 이에 대해 구글링을 해도 잘 나오지 않아서 GPT한테 물어봤다.

```
함수형 프로그래밍에서는 보통 상태 변경이나 데이터 변경을 지양합니다. 이것이 함수형 프로그래밍의 "순수성(purity)" 개념에 해당합니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며 부작용(side-effects)가 없어야 합니다.

그러나, 클로저는 함수형 프로그래밍에서 중요한 도구로서, 외부 함수의 범위에서 변수를 "캡처"하여 내부 함수가 이 변수에 액세스할 수 있게 합니다. 이를 통해 함수형 프로그래밍에서도 상태를 가질 수 있는 방법을 제공합니다.

다만 이 클로저 변수를 변경하는 것은 사실상 상태 변경을 수반하기 때문에, 순수한 함수형 패러다임에는 어긋나는 행위로 볼 수 있습니다. 하지만 실제 프로그래밍 환경에서는 순수한 함수형 패러다임만을 지키기 어렵고, 때로는 상태 변경이 필요한 경우가 있습니다.

이런 경우, 함수형 프로그래밍 언어나 라이브러리는 '불변성'을 유지하면서 상태를 업데이트하는 방법들을 제공합니다. 예를 들어, 자바스크립트의 리액트에서는 상태 변경을 위해 setState를 제공하고, 클로저를 이용해 상태를 유지하면서도 불변성을 지키는 것을 권장합니다.

따라서, 클로저를 이용해서 특정 함수가 갖는 클로저 변수의 값을 변경하는 것은 경우에 따라 함수형 패러다임에 어긋날 수 있지만, 이를 적절하게 사용하면 함수형 패러다임을 지키면서도 필요한 상태 변경을 할 수 있습니다.
```

스터디원들과도 같이 이야기해볼 예정인데, 내가 생각했던 답변이라 만족스러웠다. ㅎㅎ :) 이제는 클로저가 왜 중요하고 왜 사용하는지, 현대 라이브러리나 프레임워크에서 어떻게 활용하고 있는지 알 것 같다.

## ☀️ 오늘의 경험

### express 없이 서버 구현하기

오늘은 express 없이 서버를 구현해보았다. express 없이 서버를 구현하려면 http 모듈을 사용해야 한다. http 모듈은 node.js에 기본적으로 내장되어 있는 모듈이다. http 모듈을 사용하면 서버를 구현할 수 있지만, 실제로 코드의 가독성도 좋지 않고 라우터 처리 또한 지저분하게 분기처리해야해서 express와 같은 라이브러리를 쓰는 게 편하다. 사실 이전에는 express가 굉장히 마법같은 라이브러리라고
생각을 했는데, express 없이 http 모듈로만 서버를 간단히 작성해보니 뭐랄까... 보기 좋게 코드를 작성하고 볼 수 있게 해주는..? 진짜 조금의 편의 기능 정도를 제공한다는 느낌이 들었다. ㅎㅎㅎㅎㅎ
(물론 제공해주는 여러 middleware는 정말 편한 것 같다~!ㅋㅋㅋ)

### 서버리스 아키텍처(feat. serverless function)

막연하게 `서버리스`라는 단어를 들으면 `서버가 없다고..?`라는 생각을 했었다. 하지만 오늘 간단하게나마 netlify와 vercel의 serverless function 기능을 살펴보고선 대략적으로 서버리스가 뭔지
알 수 있었다. 서버가 없다기보다는 서버를 직접 구현하거나 라이브러리를 사용해서 서버를 구현하는 것이 아니라, 서버를 구현하는 것을 추상화시켜서 사용자가 서버를 구현하는 것처럼 보이게 하는 것이다.
예를 들어 vercel의 serverless function은 `/api` 폴더 안에 `*.js` 파일을 만들면, 해당 파일의 이름이 라우터가 되고, 파일 내부의 함수가 라우터 핸들러가 된다. 이렇게 하면 서버를 직접 구현하는 것처럼 보이지만, 실제로는 vercel이나 netlify가 서버를 구현하고, 사용자가 서버를 구현하는 것처럼 보이게 하는 것이다. 이렇게 추상화시켜서 사용자가 서버를 구현하는 것처럼 보이게 하는 것을 `서버리스 아키텍처`라고 한다. 아마 내가 알기론 이런 기능이 Next.js에 기본적으로 내장되어 있는 것 같다.

## 🐾 오늘의 교훈

처음부터 다 된다고 생각하지 말자. 새로운 걸 천천히 적용해보고 반복하면서 습관으로, 내 것으로 만들자. 떄로는 반복하고 있는 시간이 아깝다고 느낄 때도 있지만, 반복이 있기에 내 것이 되는 것이다.
그런 반복의 와중에도 어떻게 나를 좀더 한 단계 성장시킬 수 있을지 늘 생각하자. 이렇게 반복하다보면 분명 좋은 개발자가 되어있으리라 믿는다. :)

## 🪵 참고

- [책] 쏙쏙 들어오는 함수형 코딩
- [express 공식문서](https://expressjs.com/ko/)

```toc

```
